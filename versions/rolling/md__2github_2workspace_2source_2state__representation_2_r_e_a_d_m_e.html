<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: State Representation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Control Libraries<span id="projectnumber">&#160;9.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">State Representation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library provides a set of classes to represent <b>states</b>, which are specific data points (state variables) associated with a name.</p>
<p>In robotics, the most useful types of state refer to spatial properties. The joint angles of a robot arm, the 3D position and velocity of a flying drone, or the measurement of an accelerometer or force-torque sensor are all examples of instantaneous state variables. The `CartesianState` and `JointState` classes can represent such values in an internally consistent way while providing useful functions for conversions, transformations and other manipulations.</p>
<p>State classes are designed to be extensible to support more abstract state variables or properties. Another type of state is a <b>parameter</b>, which this library defines as a container class to for generic named variables.</p>
<p>The following sections describe the properties of the main state classes in the library.</p>
<h1>Table of contents:</h1>
<ul>
<li>State<ul>
<li>Name</li>
<li>State Type</li>
<li>Timestamp</li>
<li>Emptiness</li>
</ul>
</li>
<li>Cartesian state<ul>
<li>Reference frame</li>
<li>Construction</li>
<li>Cartesian getters and setters</li>
<li>Cartesian addition and subtraction</li>
<li>Cartesian transforms and changing the reference frame</li>
<li>Cartesian distances and norms</li>
</ul>
</li>
<li>Derived Cartesian classes<ul>
<li>Cartesian pose</li>
<li>Cartesian twist</li>
<li>Cartesian acceleration</li>
<li>Cartesian wrench</li>
</ul>
</li>
<li>Joint state<ul>
<li>Joint names</li>
<li>Construction</li>
<li>Joint state addition and subtraction</li>
</ul>
</li>
<li>Derived joint state classes<ul>
<li>Joint positions</li>
<li>Joint velocities</li>
<li>Joint accelerations</li>
<li>Joint torques</li>
</ul>
</li>
<li>Jacobian<ul>
<li>Reference frame and joint names</li>
<li>Construction</li>
<li>Jacobian matrix operations</li>
<li>JointVelocities to CartesianTwist</li>
<li>CartesianTwist to JointVelocities</li>
<li>CartesianWrench to JointTorques</li>
<li>Changing the Jacobian reference frame</li>
</ul>
</li>
</ul>
<h1>State</h1>
<p>The <code>State</code> base class defines the following attributes common to all derived states:</p>
<ul>
<li>name: the name associated with the state</li>
<li>type: the specific StateType of the object</li>
<li>timestamp: an internal timestamp which refers to the last modification</li>
</ul>
<h2>Name</h2>
<p>The name is used to label a specific state instance, and can be used to disambiguate multiple states or check their compatibility. The name can be accessed or modified with <code>get_name()</code> and <code>set_name()</code> respectively.</p>
<h2>State Type</h2>
<p>A state can hold different data depending on its type. The available state types are defined by the <code><a class="el" href="namespacestate__representation.html#ab8356a8dcadd21825f50bc1fd41a9e87" title="The class types inheriting from State.">state_representation::StateType</a></code> enumeration. The type field is accessible using the <code>get_type()</code> method and allows introspection when working with state pointers. It is a readonly property, determined by the constructor implementation.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keywordtype">void</span> check_state_type(<span class="keyword">const</span> std::shared_ptr&lt;state_representation::State&gt;&amp; state) {</div>
<div class="line">  <span class="keywordflow">if</span> (state-&gt;get_type() == ...) {</div>
<div class="line">    <span class="comment">// </span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2>Timestamp</h2>
<p>The timestamp of a state records when it was last modified. Any non-const operations or mutations, including copy constructions, will reset the timestamp.</p>
<p><code>get_age()</code> returns the time since last modification in seconds, while <code>is_deprecated(time_delay)</code> can be used to check the age of a state against a maximum time delay.</p>
<h2>Emptiness</h2>
<p>In addition, all states have a concept of "emptiness". The <code>State</code> base class does not refer to any specific state variable, and therefore holds no data. Derived classes that implement state variables do hold data. If a state is empty, it indicates that the data is uninitialized or otherwise invalid. The <code>is_empty()</code> method can be used to check emptiness, or otherwise the state object can be evaluated directly.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_state.html">state_representation::State</a> state;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (state) {</div>
<div class="line">  <span class="comment">// the state is not empty</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// the state is empty</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassstate__representation_1_1_state_html"><div class="ttname"><a href="classstate__representation_1_1_state.html">state_representation::State</a></div><div class="ttdoc">Abstract class to represent a state.</div><div class="ttdef"><b>Definition</b> <a href="_state_8hpp_source.html#l00025">State.hpp:25</a></div></div>
</div><!-- fragment --><p>A state can be marked as "empty" by calling <code>reset()</code>. The state remains empty until any data is set.</p>
<h1>Cartesian state</h1>
<p>A <code>CartesianState</code> represents a spatial frame in 3D space, containing the following spatial and dynamic properties:</p>
<ul>
<li><code>position</code></li>
<li><code>orientation</code></li>
<li><code>linear_velocity</code></li>
<li><code>angular_velocity</code></li>
<li><code>linear_acceleration</code></li>
<li><code>angular_acceleration</code></li>
<li><code>force</code></li>
<li><code>torque</code></li>
</ul>
<p>Each state variable is represented as a 3D vector (<code>Eigen::Vector3d</code>), except for the orientation, which is represented by a unit quaternion (<code>Eigen::Quaterniond</code>). The values are assumed to be in standard SI units (meters, radians, seconds, and Newtons).</p>
<p>The state variables can also be considered in pairs:</p>
<ul>
<li><code>pose</code> (<code>position</code> and <code>orientation</code>)</li>
<li><code>twist</code> (<code>linear_velocity</code> and <code>angular_velocity</code>)</li>
<li><code>accelerations</code> (<code>linear_acceleration</code> and <code>angular_acceleration</code>)</li>
<li><code>wrench</code> (<code>force</code> and <code>torque</code>)</li>
</ul>
<p>The linear terms always come first, followed by the angular terms.</p>
<p>Each <em>paired</em> state variable is represented as a 6D vector (<code>Eigen::VectorXd(6)</code>), except for the pose, which is represented as a 7D vector (3 for <code>position</code> and 4 for <code>orientation</code>).</p>
<h2>Reference frames</h2>
<p>The spatial properties are expressed relative to a named reference frame. For a <code>CartesianState</code> with name "A" and reference frame "B", each state variable represents the instantaneous spatial property measured at or around frame A from the perspective of frame B.</p>
<p>In some contexts, <code>twist</code> or <code>wrench</code> vectors may be interpreted differently. For example, there is a concept of "body twist" and "spatial twist". See the sections on `CartesianTwist` and `CartesianWrench` for more details.</p>
<h3 id="cartesian-state-construction">Construction</h3>
<p><code>CartesianState</code> constructors take a name and an optional reference frame; by default, the reference frame is "world".</p>
<p>Constructing a state without any data results in an empty state. To set initial data, the static constructors <code>Identity()</code> or <code>Random()</code> can be used. The former sets all vectors to zero and sets the orientation to the null quaternion. The latter sets all state variables to a unit random state within a uniform distribution.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s1(<span class="stringliteral">&quot;A&quot;</span>); <span class="comment">// frame A expressed in world (default)</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> s2(<span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>); <span class="comment">// frame B expressed in A</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> s3 = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a>(<span class="stringliteral">&quot;I&quot;</span>); <span class="comment">// identity frame I expressed in world</span></div>
<div class="line"><span class="keyword">auto</span> s4 = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;R&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>); <span class="comment">// random frame R expressed in B</span></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a></div><div class="ttdoc">Class to represent a state in Cartesian space.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8hpp_source.html#l00048">CartesianState.hpp:48</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a25b526d9023e1c101256faf26eb741e3"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a></div><div class="ttdeci">static CartesianState Random(const std::string &amp;name, const std::string &amp;reference=&quot;world&quot;)</div><div class="ttdoc">Constructor for a random Cartesian state.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00075">CartesianState.cpp:75</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a6c86224b5fed66d56e17f6772d247b59"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a></div><div class="ttdeci">static CartesianState Identity(const std::string &amp;name, const std::string &amp;reference=&quot;world&quot;)</div><div class="ttdoc">Constructor for the identity Cartesian state (identity pose and 0 for the rest)</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00068">CartesianState.cpp:68</a></div></div>
</div><!-- fragment --><h2>Cartesian getters and setters</h2>
<p>Each state variable has a corresponding getter and setter to access or modify the data after construction.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> state = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the position as a 3D vector</span></div>
<div class="line">Eigen::Vector3d xyz = state.get_position();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set the position with a 3D vector</span></div>
<div class="line">xyz = Eigen::Vector3d(1, 0, 0); <span class="comment">// 1 meter in X</span></div>
<div class="line">state.set_position(xyz);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or, set X, Y, Z values directly</span></div>
<div class="line">state.set_position(0, 0.001, 0); <span class="comment">// 1 millimeter in Y</span></div>
</div><!-- fragment --><p>The orientation operates with a quaternion instead of a 3D vector.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// get the orientation as a unit quaternion</span></div>
<div class="line">Eigen::Quaterniond q = state.get_orientation();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// set the orientation with a quaternion object</span></div>
<div class="line">q = Eigen::Quaterniond(0, 1, 0, 0); <span class="comment">// 180º rotation around X</span></div>
<div class="line">state.set_orientation(q);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// or, set W, X, Y, Z values directly</span></div>
<div class="line">state.set_orientation(0, 0, 0, 1); <span class="comment">// 180º rotation around Z</span></div>
</div><!-- fragment --><p>Whenever setting the orientation, the values are automatically normalized to ensure a unit quaternion.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">s2.set_orientation(1, 1, 0, 0); <span class="comment">// 90º rotation around X</span></div>
<div class="line">s2.get_orientation(); <span class="comment">// Eigen::Quaterniond(0.70710678, 0.70710678, 0., 0.)</span></div>
</div><!-- fragment --><p>Every other 3D state variable has equivalent getters and setters to the position:</p>
<ul>
<li><code>get_linear_velocity()</code>, <code>set_linear_velocity(xyz)</code> or <code>set_linear_velocity(x, y, z)</code> in meters per second</li>
<li><code>get_angular_velocity()</code>, <code>set_angular_velocity(xyz)</code> or <code>set_angular_velocity(x, y, z)</code> in radians per second</li>
<li><code>get_linear_acceleration()</code>, <code>set_linear_acceleration(xyz)</code> or <code>set_linear_acceleration(x, y, z)</code> in meters per second squared</li>
<li><code>get_angular_acceleration()</code>, <code>set_angular_acceleration(xyz)</code> or <code>set_angular_acceleration(x, y, z)</code> in radians per second squared</li>
<li><code>get_force()</code>, <code>set_force(xyz)</code> or <code>set_force(x, y, z)</code> in Newtons</li>
<li><code>get_torque()</code>, <code>set_torque(xyz)</code> or <code>set_torque(x, y, z)</code> in Newton-meters</li>
</ul>
<p>The paired state variables (<code>pose</code>, <code>twist</code>, <code>acceleration</code>, <code>wrench</code>) also have their own getters and setters to modify the underlying terms in one operation.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::VectorXd pose = state.get_pose(); <span class="comment">// 7D vector of position and orientation</span></div>
<div class="line">pose = {x, y, z, qw, qx, qy, qz};</div>
<div class="line">s2.set_pose(pose); <span class="comment">// update the position and orientation</span></div>
<div class="line"> </div>
<div class="line">Eigen::VectorXd twist = state.get_twist(); <span class="comment">// 6D vector of linear and angular velocity</span></div>
<div class="line">state.set_twist(Eigen::VectorXd::Random(6)); <span class="comment">// update the linear and angular velocity</span></div>
<div class="line"> </div>
<div class="line">Eigen::VectorXd acceleration = state.get_acceleration(); <span class="comment">// 6D vector of linear and angular acceleration</span></div>
<div class="line">state.set_acceleration(Eigen::VectorXd::Random(6)); <span class="comment">// update the linear and angular acceleration</span></div>
<div class="line"> </div>
<div class="line">Eigen::VectorXd wrench = state.get_wrench(); <span class="comment">// 6D vector of force and torque</span></div>
<div class="line">state.set_wrench(Eigen::VectorXd::Random(6)); <span class="comment">// update the force and torque</span></div>
</div><!-- fragment --><h2>Cartesian addition and subtraction</h2>
<p>In robotics and control, a state variable can represent a command or desired value, rather than a real measurement. For this reason, it's often desirable to combine and manipulate state variables in different ways.</p>
<p>For example, a simple controller might be driving the linear velocity of a robot to approach a moving object. Then, the desired velocity of the robot would be the velocity of the object <em>plus</em> some additional velocity in the direction of the object.</p>
<p>Two <code>CartesianState</code> objects can be combined with addition or subtraction, <b>provided they are expressed in the same reference frame</b>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> s1 = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;a&quot;</span>); <span class="comment">// reference frame is world by default</span></div>
<div class="line"><span class="keyword">auto</span> s2 = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;b&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> sum = s1 + s2;</div>
<div class="line"><span class="keyword">auto</span> diff = s1 - s2;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// if the states are not in the same reference frame, it will raise an exception</span></div>
<div class="line">s1 + <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;other&quot;</span>);</div>
</div><!-- fragment --><p>For all state variables except orientation, the result of the operation is applied to each state variable element-wise. For example, if <code>s1</code> has position <code>(x1, y1, z1)</code> and <code>s2</code> has position <code>(x1, y1, z1)</code>, then <code>s1 + s2</code> has position <code>(x1 + x2, y1 + y2, z1 + z2)</code>. The same applies for subtraction and is true for all state variables represented as 3D vectors.</p>
<p>In the case of orientation, the addition and subtraction operations are <b>not commutative</b>.</p>
<p>Addition of orientation uses the quaternion product; the addition <code>s1 + s2</code> corresponds to the rotation of <code>s1</code> followed by the rotation in <code>s2</code>, while <code>s2 + s1</code> corresponds to the rotation of <code>s2</code> followed by the rotation of <code>s1</code>.</p>
<p>Subtraction of orientation uses the quaternion inverse (quaternion conjugate); <code>-s1</code> yields the inverse orientation of <code>s1</code>, and <code>s1 - s2</code> is equivalent to the rotation of <code>s1</code> followed by the inverse rotation of <code>s2</code>.</p>
<h2>Cartesian transforms: changing the reference frame</h2>
<p>A <code>CartesianState</code> represents the spatial properties of a frame as viewed from a certain reference frame. Observing the same frame from a different reference frame can change the relative values of each state variable.</p>
<p>If two observers are looking at the same frame from different locations, they will observe the frame with a different relative position and orientation. Similarly, if one observer is moving while the other is stationary, they will observe the frame with different relative velocities.</p>
<p>If some frame A is observed from reference frame B, and frame B is itself observed from another reference frame C, then it is possible to express frame A relative to reference frame C. Expressing the spatial properties of a frame in different reference frames is known as a <b>transformation</b> and is one of the most useful operations of the <code>CartesianState</code> class.</p>
<p>A transformation affects all state variables as a combination of the two connected frames. In the simplest case, the relative distance between each frame is combined to yield a new position value. In another example, if frame A is rotated by 45 degrees relative to B and B is rotated 45 degrees relative to C, then A is rotated 90 degrees relative to C.</p>
<p>When states have non-zero position, orientation, velocity or acceleration offsets, the transformation involves a more complicated combination of the different state variables.</p>
<p>If there is an orientation difference between the frames, the vectors representing each state variable are rotated into the new reference frame accordingly.</p>
<p>Transformations including twist will include radially-induced linearly velocity that scales with the distance between frames and their relative angular velocities. Finally, the transformation of accelerating frames will include Coriolis and centrifugal effects.</p>
<p>Transformation applies only to the relative spatial properties of the frame (pose, twist, and acceleration). The wrench is not transformed in the same way because forces applied to spatial frames do not "add together" like relative positions or velocities. A measured force or torque will therefore not change in magnitude when expressed in different reference frames, and is only rotated to the new reference frame coordinate system.</p>
<p>The concept of a wrench transform does exist in the context of static forces across rigid bodies. This is described further in the `CartesianWrench` section.</p>
<h3>The transform operator</h3>
<p>For clarity in the examples below, the name given to each <code>CartesianState</code> variable will have the reference name as the prefix and the frame name as a suffix. This will highlight the "chain rule" that occurs during frame transformations.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// frame &quot;a&quot; expressed in reference frame &quot;world&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> wSa(<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line"><span class="comment">// frame &quot;b&quot; expressed in reference frame &quot;a&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> aSb(<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>);</div>
</div><!-- fragment --><p>The multiplication operator is used to transform states by chaining together connected frames and reference frames.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// the state of frame &quot;b&quot; expressed in reference frame &quot;world&quot; is found by</span></div>
<div class="line"><span class="comment">// combining frame &quot;a&quot; in &quot;world&quot; with frame &quot;b&quot; in &quot;a&quot;</span></div>
<div class="line"><span class="keyword">auto</span> wSb = wSa * aSb;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the chain rule applies whenever the &quot;inner frames&quot; are compatible</span></div>
<div class="line"><span class="keyword">auto</span> wSd = wSb * bSc * cSd;</div>
</div><!-- fragment --><p>As can be seen in the above examples, the frame of the left state should match the reference frame of the right state, causing the inner frames to cancel out. This is analogous to the product of two matrices, wherein the inner sizes must be compatible. If the frame names do not match, the states are not compatible and an exception will be raised.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// error: inner frames are not compatible!</span></div>
<div class="line">wSa * bSc;</div>
</div><!-- fragment --><p>In some cases, there may be enough information to perform a transformation, but the inner frames are not compatible.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// inner frames are not compatible, but it should still be possible to find &quot;b&quot; relative to &quot;world&quot;</span></div>
<div class="line">wSa * bSa;</div>
</div><!-- fragment --><p>To resolve this case, inversion can be used.</p>
<h3>Inversion</h3>
<p>It is possible to invert a state using the <code>inverse()</code> operator, which essentially reverses the frame and reference frame. Instead of observing a frame "A" from a reference frame "B", the inverse expresses "B" as observed from "A".</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">aSb = bSa.inverse();</div>
</div><!-- fragment --><p>In the context of the transformation chain rule, this can be used to resolve otherwise incompatible operations. This is analogous to transposing a matrix so that the inner sizes of a product match.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// wSa * bSa is not possible, but wSa * aSb would be</span></div>
<div class="line">wSb = wSa * bSa.inverse() = wSa * aSb</div>
</div><!-- fragment --><p>An inversion sets the new orientation as the quaternion conjugate and effectively negates and rotates all other state variable vectors.</p>
<p>As with transformation, the wrench is the special case. For a state <code>aSb</code>, the wrench describes the force and torque measured at <code>b</code> as seen from <code>a</code>. For the inverted state <code>bSa</code>, the wrench at <code>a</code> is unknown without further underlying assumptions. For this reason, the inverse operator sets the resulting wrench to zero.</p>
<h2>Cartesian distances and norms</h2>
<p>As a <code>CartesianState</code> represents a spatial transformation, distance between states and norms computations have been implemented. The distance functions is represented as the sum of the distance over all the state variables:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacestate__representation.html">state_representation</a>;</div>
<div class="line"><span class="keyword">auto</span> cs1 = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> cs2 = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> d = cs1.dist(cs2);</div>
<div class="line"><span class="comment">// alternatively one can use the friend type notation</span></div>
<div class="line">d = <a class="code hl_function" href="namespacestate__representation.html#a19d515e5b5252641cf0796315baef1f6">state_representation::dist</a>(cs1, cs2)</div>
<div class="ttc" id="anamespacestate__representation_html"><div class="ttname"><a href="namespacestate__representation.html">state_representation</a></div><div class="ttdoc">Core state variables and objects.</div><div class="ttdef"><b>Definition</b> <a href="_analog_i_o_state_8hpp_source.html#l00005">AnalogIOState.hpp:5</a></div></div>
<div class="ttc" id="anamespacestate__representation_html_a19d515e5b5252641cf0796315baef1f6"><div class="ttname"><a href="namespacestate__representation.html#a19d515e5b5252641cf0796315baef1f6">state_representation::dist</a></div><div class="ttdeci">double dist(const CartesianState &amp;s1, const CartesianState &amp;s2, const CartesianStateVariable &amp;state_variable_type=CartesianStateVariable::ALL)</div><div class="ttdoc">Compute the distance between two Cartesian states.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00515">CartesianState.cpp:515</a></div></div>
</div><!-- fragment --><p>By default, the distance is computed over all the state variables by combining the Euclidean distance between each state vector and adding the angular distance in radians in the case of orientation.</p>
<p>Because the distance is summed over independent spatial terms, the final value has no physical units but can still be useful when comparing the relative similarity of two states.</p>
<p>To find a difference in a specific state variable, the <code>CartesianStateVariable</code> enumeration can be used:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// only the distance in meters</span></div>
<div class="line"><span class="keywordtype">double</span> distance = cs1.dist(cs2, CartesianStateVariable::POSITION);</div>
<div class="line"><span class="comment">// only the angular distance in radians</span></div>
<div class="line"><span class="keywordtype">double</span> angle = cs1.dist(cs2, CartesianStateVariable::ORIENTATION);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// only the angular velocity difference in radians per second</span></div>
<div class="line"><span class="keywordtype">double</span> angular_rate = cs1.dist(cs2, CartesianStateVariable::ANGULAR_VELOCITY);</div>
</div><!-- fragment --><p>The Euclidean norm of individual state variables returns the vector magnitude (or angular displacement in the case of orientation). To get the magnitude of all state variables as a vector of norms, use the <code>norms()</code> operator.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> state = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;test&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the default usage returns the magnitude of all state variables in an 8D vector</span></div>
<div class="line">std::vector&lt;double&gt; norms = state.norms();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// to return 2D vectors of norms, filter by the combined state variables</span></div>
<div class="line">std::vector&lt;double&gt; distance_and_angle = state.norms(CartesianStateVariable::POSE);</div>
<div class="line">std::vector&lt;double&gt; speeds = state.norms(CartesianStateVariable::TWIST);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// other single state variables give a 1D vector</span></div>
<div class="line">std::vector&lt;double&gt; distance = state.norms(CartesianStateVariable::POSITION);</div>
</div><!-- fragment --><p>Finally, state variables can be scaled to a unit vector state using the <code>normalize()</code> / <code>normalized()</code> operations. This does not affect the orientation, which is always expressed as a unit quaternion.</p>
<p>The former normalizes a state in place, while the latter returns a normalized copy without modifying the original state.</p>
<p>As with the other operations, the normalization can be selectively applied to specific state variables.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// normalize a state all the state variables</span></div>
<div class="line">state.normalize();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// normalize the position of a state to a unit direction vector</span></div>
<div class="line">state.normalize(CartesianStateVariable::POSITION);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// copied state with only linear velocity normalized</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> normalized_state = state.normalized(CartesianStateVariable::LINEAR_VELOCITY);</div>
</div><!-- fragment --><h1>Derived Cartesian classes</h1>
<p>The <code>CartesianState</code> class contains all spatial and dynamic state variables of a frame. In some cases, it is convenient to operate only with specific state variables. The following derived classes are defined:</p>
<ul>
<li><code>CartesianPose</code></li>
<li><code>CartesianTwist</code></li>
<li><code>CartesianAcceleration</code></li>
<li><code>CartesianWrench</code></li>
</ul>
<h2>Cartesian pose</h2>
<p>The <code>CartesianPose</code> class defines only the position and orientation of a frame.</p>
<p>It provides the following constructors:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">CartesianPose::Identity(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line">CartesianPose::Random(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the position can be supplied to the constructor as a vector or as individual terms (with null orientation)</span></div>
<div class="line">xyz = Eigen::Vector3d(1.0, 2.0, 3.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a>(<span class="stringliteral">&quot;name&quot;</span>, xyz, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a>(<span class="stringliteral">&quot;name&quot;</span>, 1.0, 2.0, 3.0, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the orientation can be supplied to the constructor as a vector or as individual terms (with zero displacement)</span></div>
<div class="line">q = Eigen::Quaterniond(0, 1, 0, 0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a>(<span class="stringliteral">&quot;name&quot;</span>, q, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the position and orientation can also be supplied together</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a>(<span class="stringliteral">&quot;name&quot;</span>, xyz, q, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_pose_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a></div><div class="ttdoc">Class to define Cartesian pose in Cartesian space as 3D position and quaternion based orientation.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_pose_8hpp_source.html#l00018">CartesianPose.hpp:18</a></div></div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>CartesianPose</code> and <code>CartesianState</code>. Recall that these operations are not commutative in orientation; the order of operations matters.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> r1 = pose + other_pose;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r2 = pose + state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r3 = state + pose;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> r4 = pose - other_pose;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r5 = pose - state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r6 = state - pose;</div>
<div class="line"> </div>
<div class="line">pose += other_pose; <span class="comment">// equivalent to pose = pose + other_pose</span></div>
<div class="line">pose += state; <span class="comment">// equivalent to pose = pose + state</span></div>
<div class="line"> </div>
<div class="line">pose -= other_pose;</div>
<div class="line">pose -= state;</div>
</div><!-- fragment --><p>A <code>CartesianPose</code> can be used to transform any other Cartesian class by applying the position and orientation offset. Recall that the frame and reference frames must be compatible according to the chain rule as described in the Cartesian transformation section.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">CartesianPose</a> transformed_pose = pose * other_pose;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> transformed_twist = pose * twist;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">CartesianAcceleration</a> transformed_acceleration = pose * acceleration;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> transformed_wrench = pose * wrench;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> transformed_state = pose * state</div>
<div class="line">    </div>
<div class="line">pose *= other_pose; <span class="comment">// equivalent to pose = pose * other_pose</span></div>
<div class="line">pose *= state; <span class="comment">// equivalent to pose = pose * state</span></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_acceleration_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_acceleration.html">state_representation::CartesianAcceleration</a></div><div class="ttdoc">Class to define acceleration in Cartesian space as 3D linear and angular acceleration vectors.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_acceleration_8hpp_source.html#l00018">CartesianAcceleration.hpp:18</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_twist_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a></div><div class="ttdoc">Class to define twist in Cartesian space as 3D linear and angular velocity vectors.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_twist_8hpp_source.html#l00018">CartesianTwist.hpp:18</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_wrench_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_wrench.html">state_representation::CartesianWrench</a></div><div class="ttdoc">Class to define wrench in Cartesian space as 3D force and torque vectors.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_wrench_8hpp_source.html#l00018">CartesianWrench.hpp:18</a></div></div>
</div><!-- fragment --><p>The time derivative of a <code>CartesianPose</code> is a <code>CartesianTwist</code>. Because <code>CartesianPose</code> represents a displacement in position and orientation, it can be converted into linear and angular velocity through division by a time period.</p>
<p>Operations with time use <code>std::chrono::duration</code> types, such as <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>, or definitions with <code>std::literals::chrono_literals</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// take a pose with a displacement of 1 meter in the X axis and 90º (π/2) rotation around the Z axis</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> pose(<span class="stringliteral">&quot;a&quot;</span>, Eigen::Vector3d(1, 0, 0), Eigen::Quaterniond(0.707, 0, 0, 0.707));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a 2 second time duration</span></div>
<div class="line">std::chrono::seconds dt(2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// dividing pose by time yields a twist with a linear velocity of 0.5 meters per second in the X axis</span></div>
<div class="line"><span class="comment">// and an angular velocity of π/4 radians per second (45º/s) around the Z axis</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> twist = pose / dt;</div>
<div class="line">twist.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a3377043ab23025749d69af46c9be50ba">get_linear_velocity</a>(); <span class="comment">// (0.5, 0, 0)</span></div>
<div class="line">twist.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#ab3281b9b4229c6409add6edcab777340">get_angular_velocity</a>(); <span class="comment">// (0, 0, 0.785)</span></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a3377043ab23025749d69af46c9be50ba"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a3377043ab23025749d69af46c9be50ba">state_representation::CartesianState::get_linear_velocity</a></div><div class="ttdeci">const Eigen::Vector3d &amp; get_linear_velocity() const</div><div class="ttdoc">Getter of the linear velocity attribute.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00164">CartesianState.cpp:164</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_ab3281b9b4229c6409add6edcab777340"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#ab3281b9b4229c6409add6edcab777340">state_representation::CartesianState::get_angular_velocity</a></div><div class="ttdeci">const Eigen::Vector3d &amp; get_angular_velocity() const</div><div class="ttdoc">Getter of the angular velocity attribute.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00169">CartesianState.cpp:169</a></div></div>
</div><!-- fragment --><h2>Cartesian twist</h2>
<p>The <code>CartesianTwist</code> class defines only the linear and angular velocity of a frame.</p>
<p>It provides the following constructors:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">CartesianTwist::Zero(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line">CartesianTwist::Random(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the linear or angular velocities can be supplied to the constructor as vectors</span></div>
<div class="line">linear_velocity = Eigen::Vector3d(1.0, 2.0, 3.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a>(<span class="stringliteral">&quot;name&quot;</span>, linear_velocity, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line">angular_velocity = Eigen::Vector3d(4.0, 5.0, 6.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a>(<span class="stringliteral">&quot;name&quot;</span>, linear_velocity, angular_velocity, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the full 6D twist vector can also be supplied</span></div>
<div class="line">twist = Eigen::VectorXd(6);</div>
<div class="line">twist &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a>(<span class="stringliteral">&quot;name&quot;</span>, twist, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>CartesianTwist</code> and <code>CartesianState</code>.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> r1 = twist + other_twist;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r2 = twist + state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r3 = state + twist;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">CartesianTwist</a> r4 = twist - other_twist;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r5 = twist - state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r6 = state - twist;</div>
<div class="line"> </div>
<div class="line">twist += other_twist; <span class="comment">// equivalent to twist = twist + other_twist</span></div>
<div class="line">twist += state; <span class="comment">// equivalent to twist = twist + state</span></div>
<div class="line"> </div>
<div class="line">twist -= other_twist;</div>
<div class="line">twist -= state;</div>
</div><!-- fragment --><p>The time derivative of a <code>CartesianTwist</code> is a <code>CartesianAcceleration</code>. Because <code>CartesianTwist</code> represents linear and angular velocity in meters and radians per seconds, it can be converted into linear and angular acceleration in meters and radians per second squared through division by a time period.</p>
<p>Similarly, the time integral of a <code>CartesianTwist</code> is a <code>CartesianPose</code>. It can be converted into a position and orientation displacement through multiplication by a time period.</p>
<p>Operations with time use <code>std::chrono::duration</code> types, such as <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>, or definitions with <code>std::literals::chrono_literals</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// take a twist with a linear velocity of 1 meter per second in the X axis</span></div>
<div class="line"><span class="comment">// and angular velocity of 1 radian per second in the Z axis </span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> twist(<span class="stringliteral">&quot;a&quot;</span>, Eigen::Vector3d(1, 0, 0), Eigen::Vector3d(0, 0, 1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a 0.5 second time duration</span></div>
<div class="line">std::chrono::milliseconds dt(500);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// dividing twist by time yields an acceleration with a linear term of 2 meters per second squared in the X axis</span></div>
<div class="line"><span class="comment">// and angular term of 2 radians per second squared around the Z axis</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">state_representation::CartesianAcceleration</a> acc = twist / dt;</div>
<div class="line">acc.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a77209999e72d36840496064dacfbe127">get_linear_acceleration</a>(); <span class="comment">// (2, 0, 0) </span></div>
<div class="line">acc.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#ad52064d4479f51dac0595ad5dc49d5cf">get_angular_acceleration</a>(); <span class="comment">// (0, 0, 2)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// multiplying twist by time yields a pose with a position of 0.5 meters in the X axis</span></div>
<div class="line"><span class="comment">// and a rotation of 0.5 radians around the Z axis</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> pose = twist * dt;</div>
<div class="line">pose.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a43cd6447377a25955a4d5397325ab3fb">get_position</a>(); <span class="comment">// (0.5, 0, 0)</span></div>
<div class="line">pose.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a97a6b4c430a570436e227ff7e90906b9">get_orientation</a>(); <span class="comment">// Eigen::Quaterniond(0.9689124, 0, 0, 0.247404)</span></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a43cd6447377a25955a4d5397325ab3fb"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a43cd6447377a25955a4d5397325ab3fb">state_representation::CartesianState::get_position</a></div><div class="ttdeci">const Eigen::Vector3d &amp; get_position() const</div><div class="ttdoc">Getter of the position attribute.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00139">CartesianState.cpp:139</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a77209999e72d36840496064dacfbe127"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a77209999e72d36840496064dacfbe127">state_representation::CartesianState::get_linear_acceleration</a></div><div class="ttdeci">const Eigen::Vector3d &amp; get_linear_acceleration() const</div><div class="ttdoc">Getter of the linear acceleration attribute.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00178">CartesianState.cpp:178</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a97a6b4c430a570436e227ff7e90906b9"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a97a6b4c430a570436e227ff7e90906b9">state_representation::CartesianState::get_orientation</a></div><div class="ttdeci">const Eigen::Quaterniond &amp; get_orientation() const</div><div class="ttdoc">Getter of the orientation attribute.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00144">CartesianState.cpp:144</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_ad52064d4479f51dac0595ad5dc49d5cf"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#ad52064d4479f51dac0595ad5dc49d5cf">state_representation::CartesianState::get_angular_acceleration</a></div><div class="ttdeci">const Eigen::Vector3d &amp; get_angular_acceleration() const</div><div class="ttdoc">Getter of the angular acceleration attribute.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00183">CartesianState.cpp:183</a></div></div>
</div><!-- fragment --><p>Note that the result of the integration is a displacement from a null (identity) pose. To offset the integration, simply add an initial pose in the same reference frame as the twist.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// add an initial pose to offset the integration </span></div>
<div class="line">pose = initial_pose + twist * dt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// a pose can also be updated through a continuous integration of twist</span></div>
<div class="line">pose += twist * dt;</div>
</div><!-- fragment --><h3>Representations of twist</h3>
<p>A <code>CartesianTwist("B", "A")</code> represents linear and angular velocity of the body frame B with respect to fixed frame A, as viewed from A.</p>
<p>$$^A\mathcal{V}_B = \begin{bmatrix} ^Av_B \ ^A\omega_B \end{bmatrix}$$</p>
<p>The <em>body twist</em> $^B\mathcal{V}^b_{AB}$ is a special 6-vector that represents linear and angular velocity of the body frame B with respect to fixed frame A, <em>as viewed from B</em>. The relationship between ${^A}\mathcal{V_B}$ and ${^B}\mathcal{V}{^b}_{AB}$ is given by the rotation matrix $^BR_A = ({^A}R_B)^T$.</p>
<p>$$^B\mathcal{V}^b_{AB} = \begin{bmatrix} v_b \ \omega_b \end{bmatrix} = \begin{bmatrix} ^BR_A * {^A}v_B \ ^BR_A * {^A}\omega_B \end{bmatrix}$$</p>
<p>For example, a spinning top (body frame) on a table (spatial reference frame) has angular velocity about its local Z axis. While the top is vertical (aligned with the table), the <code>CartesianTwist</code> and the body twist are equivalent. If the top begins to precess and tips over, then the <code>CartesianTwist</code> (expressed in the table frame) will show an angular velocity with components in X and Y, but the body twist will remain expressed in the local body Z axis. Importantly, the magnitude of the twist is the same in both representations, because they are both measuring the twist of the top with respect to the table.</p>
<p>There is another type of twist called the <em>spatial twist</em>. Just like <code>CartesianTwist</code>, it represents angular velocity of the body frame B with respect to fixed frame A, as viewed from A. However, the spatial linear velocity $v_s$ represents the velocity of an imaginary point at A as if it were attached to the body B, measured with respect to A, as viewed from A.</p>
<p>$$^A\mathcal{V}^s_{AB} = \begin{bmatrix} v_s \ \omega_s \end{bmatrix} = \begin{bmatrix} {^A}v_B + {^A}t_B \times {^A}\omega_B \ {^A}\omega_B \end{bmatrix}$$</p>
<p>The quantity $v_s$ is the body linear velocity plus the radially induced velocity as the cross product of the distance from A to B ${^A}t_B$ with the body angular velocity.</p>
<p>The internal <code>CartesianTwist</code> representation is arguably the most intuitive out of all three options presented here. Still, depending on the geometric operations involved, both the body and spatial twist vectors can be useful.</p>
<p>The equations above have shown the derivations of each in terms of the original <code>CartesianTwist</code>. For completeness, it is also worth mentioning the direct transformation between body and spatial representations, using the Adjoint map.</p>
<p>$$\mathcal{V}_s = [Ad_{T}] \mathcal{V}_b$$</p>
<p>The Adjoint map is defined for a given transformation matrix $T$ (with rotation matrix $R$ and displacement vector $t$) as the adjoint matrix $[Ad_{T}]$:</p>
<p>$$[Ad_{T}] = \begin{bmatrix} 0 &amp; R \ R &amp; [t]_{\times}R \end{bmatrix}$$</p>
<p>The inverse of the adjoint matrix maps from spatial to body frame, and can be found by using the inverse transformation matrix.</p>
<p>$$^A\mathcal{V}^s_{AB} = [Ad_{^AT_B}] ^B\mathcal{V}^b_{AB}$$</p>
<p>$$^B\mathcal{V}^b_{AB} = [Ad_{^BT_A}] ^A\mathcal{V}^s_{AB}$$</p>
<h2>Cartesian acceleration</h2>
<p>The <code>CartesianAcceleration</code> class defines only the linear and angular acceleration of a frame.</p>
<p>It provides the following constructors:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">CartesianAcceleration::Zero(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line">CartesianAcceleration::Random(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the linear or angular accelerations can be supplied to the constructor as vectors</span></div>
<div class="line">linear_acceleration = Eigen::Vector3d(1.0, 2.0, 3.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">CartesianAcceleration</a>(<span class="stringliteral">&quot;name&quot;</span>, linear_acceleration, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line">angular_acceleration = Eigen::Vector3d(4.0, 5.0, 6.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">CartesianAcceleration</a>(<span class="stringliteral">&quot;name&quot;</span>, linear_acceleration, angular_acceleration, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the full 6D acceleration vector can also be supplied</span></div>
<div class="line">acceleration = Eigen::VectorXd(6);</div>
<div class="line">acceleration &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">CartesianAcceleration</a>(<span class="stringliteral">&quot;name&quot;</span>, acceleration, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>CartesianAcceleration</code> and <code>CartesianState</code>.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">CartesianAcceleration</a> r1 = acceleration + other_acceleration;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r2 = acceleration + state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r3 = state + acceleration;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">CartesianAcceleration</a> r4 = acceleration - other_acceleration;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r5 = acceleration - state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r6 = state - acceleration;</div>
<div class="line"> </div>
<div class="line">acceleration += other_acceleration; <span class="comment">// equivalent to acceleration = acceleration + other_acceleration</span></div>
<div class="line">acceleration += state; <span class="comment">// equivalent to acceleration = acceleration + state</span></div>
<div class="line"> </div>
<div class="line">acceleration -= other_acceleration;</div>
<div class="line">acceleration -= state;</div>
</div><!-- fragment --><p>The time integral of a <code>CartesianAcceleration</code> is a <code>CartesianTwist</code>. Because <code>CartesianAcceleration</code> represents linear and angular acceleration in meters and radians per seconds squared, it can be converted into a relative linear and angular velocity in meters and radians per second through multiplication by a time period.</p>
<p>Operations with time use <code>std::chrono::duration</code> types, such as <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>, or definitions with <code>std::literals::chrono_literals</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// take an acceleration with a linear acceleration of 1 meter per second squared in the X axis</span></div>
<div class="line"><span class="comment">// and angular acceleration of 1 radian per second squared in the Z axis </span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_acceleration.html">state_representation::CartesianAcceleration</a> acc(<span class="stringliteral">&quot;a&quot;</span>, Eigen::Vector3d(1, 0, 0), Eigen::Vector3d(0, 0, 1));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a 0.1 second time duration</span></div>
<div class="line">std::chrono::milliseconds dt(100);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// multiplying acceleration by time yields a twist with a linear term of 0.1 meters per second in the X axis</span></div>
<div class="line"><span class="comment">// and an angular term of 0.1 radians per second around the Z axis</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_pose.html">state_representation::CartesianPose</a> twist = acceleration * dt;</div>
<div class="line">pose.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a43cd6447377a25955a4d5397325ab3fb">get_position</a>(); <span class="comment">// (0.1, 0, 0)</span></div>
<div class="line">pose.<a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a97a6b4c430a570436e227ff7e90906b9">get_orientation</a>(); <span class="comment">// (0, 0, 0.1)</span></div>
</div><!-- fragment --><p>Note that the result of the integration assumes zero initial velocity. To offset the integration, simply add an initial twist in the same reference frame as the acceleration.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// add an initial twist to offset the integration </span></div>
<div class="line">twist = initial_twist + acc * dt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// a twist can also be updated through a continuous integration of acceleration</span></div>
<div class="line">twist += acc * dt;</div>
</div><!-- fragment --><h2>Cartesian wrench</h2>
<p>The <code>CartesianWrench</code> class defines only the force and torque as applied to a frame.</p>
<p>It provides the following constructors:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">CartesianWrench::Zero(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line">CartesianWrench::Random(<span class="stringliteral">&quot;name&quot;</span>, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the force or torque can be supplied to the constructor as vectors</span></div>
<div class="line">force = Eigen::Vector3d(1.0, 2.0, 3.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a>(<span class="stringliteral">&quot;name&quot;</span>, force, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line">torque = Eigen::Vector3d(4.0, 5.0, 6.0);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a>(<span class="stringliteral">&quot;name&quot;</span>, force, torque, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the full 6D wrench vector can also be supplied</span></div>
<div class="line">wrench = Eigen::VectorXd(6);</div>
<div class="line">wrench &lt;&lt; 1.0, 2.0, 3.0, 4.0, 5.0, 6.0;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a>(<span class="stringliteral">&quot;name&quot;</span>, wrench, <span class="stringliteral">&quot;reference_frame&quot;</span>);</div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>CartesianWrench</code> and <code>CartesianState</code>.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> r1 = wrench + other_wrench;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r2 = wrench + state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r3 = state + wrench;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_wrench.html">CartesianWrench</a> r4 = wrench - other_wrench;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r5 = wrench - state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> r6 = state - wrench;</div>
<div class="line"> </div>
<div class="line">wrench += other_wrench; <span class="comment">// equivalent to wrench = wrench + other_wrench</span></div>
<div class="line">wrench += state; <span class="comment">// equivalent to wrench = wrench + state</span></div>
<div class="line"> </div>
<div class="line">wrench -= other_wrench;</div>
<div class="line">wrench -= state;</div>
</div><!-- fragment --><h3>Considerations of wrench</h3>
<p>The wrench is distinct from the other state variables as it is not a relative spatial property. It is considered as the measurement of a force/torque sensor at the frame, as seen from the reference frame.</p>
<p>Changing the observer does not change magnitude of the force or wrench measured at the frame. It only changes the apparent direction of the wrench vector, depending on the orientation of the reference frame.</p>
<p>Because the <code>CartesianWrench</code> is different from other spatial properties, it is handled uniquely in the transform and inverse operations.</p>
<p>A transformation of states involving a wrench will only preserve the wrench measured at the last frame, rotated to the new reference frame. The wrench of the intermediate (inner) frame is discarded.</p>
<p>The inverse of a state will set the wrench to zero.</p>
<h1>Joint state</h1>
<p>A <code>JointState</code> represents the instantaneous properties of a collection of joints, containing the following spatial and dynamic properties:</p>
<ul>
<li><code>positions</code></li>
<li><code>velocities</code></li>
<li><code>accelerations</code></li>
<li><code>torques</code></li>
</ul>
<p>Each state variable is represented as an N-dimensional vector (<code>Eigen::VectorXd</code>), where N is the number of joints.</p>
<p>By design, a <code>JointState</code> most appropriately describes a serial linkage of revolute joints as found in typical robot arms or manipulators. The values are assumed to be in standard SI units (radians, seconds, Newton-meters).</p>
<h2>Joint names</h2>
<p>Each joint in a <code>JointState</code> collection has a name. This can make it easier to reference the state variable value of a specific joint in the collection.</p>
<p>The names can be set on construction or using the <code>set_names()</code> method. As an example, a three-link robot might be given joint names <code>{"shoulder", "elbow", "wrist"}</code>.</p>
<p>By default, the names are assigned based on their index, starting from 0: <code>{"joint0", "joint1", ..., "jointX"}</code>.</p>
<h3 id="joint-state-construction">Construction</h3>
<p><code>JointState</code> constructors take a name and either a vector of joint names or an integer number of joints. The name refers to the whole joint state collection, and so often corresponds to the name of the robot it represents.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// create a joint state for a robot with 3 joints</span></div>
<div class="line">std::vector&lt;string&gt; joint_names = { <span class="stringliteral">&quot;shoulder&quot;</span>, <span class="stringliteral">&quot;elbow&quot;</span>, <span class="stringliteral">&quot;wrist&quot;</span> };</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js1(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js2(<span class="stringliteral">&quot;my_robot&quot;</span>, 3); <span class="comment">// joint names are defaulted to &quot;joint0&quot;, &quot;joint1&quot;, &quot;joint2&quot;</span></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a></div><div class="ttdoc">Class to define a state in joint space.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8hpp_source.html#l00035">JointState.hpp:35</a></div></div>
</div><!-- fragment --><p>Constructing a state without any data results in an empty state. To set initial data, the static constructors <code>Zero()</code> or <code>Random()</code> can be used. The former sets all state variables of each joint values zero. The latter sets all state variables to a unit random state within a uniform distribution. As with the regular constructor, a vector of joint names or an integer number of joints can be supplied.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// initialize the joint state to zero values</span></div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a4cc5fdffbf317fd0f44c5146771d5149">state_representation::JointState::Zero</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names);</div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a4cc5fdffbf317fd0f44c5146771d5149">state_representation::JointState::Zero</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize the joint state to random values</span></div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a2939ab85acce8605260589f376d4ffa9">state_representation::JointState::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names);</div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a2939ab85acce8605260589f376d4ffa9">state_representation::JointState::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3);</div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html_a2939ab85acce8605260589f376d4ffa9"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html#a2939ab85acce8605260589f376d4ffa9">state_representation::JointState::Random</a></div><div class="ttdeci">static JointState Random(const std::string &amp;robot_name, unsigned int nb_joints)</div><div class="ttdoc">Constructor for a random joint state.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8cpp_source.html#l00073">JointState.cpp:73</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html_a4cc5fdffbf317fd0f44c5146771d5149"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html#a4cc5fdffbf317fd0f44c5146771d5149">state_representation::JointState::Zero</a></div><div class="ttdeci">static JointState Zero(const std::string &amp;robot_name, unsigned int nb_joints)</div><div class="ttdoc">Constructor for a zero joint state.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8cpp_source.html#l00059">JointState.cpp:59</a></div></div>
</div><!-- fragment --><h2>Joint getters and setters</h2>
<p>Each state variable has a corresponding getter and setter to access or modify the data after construction.</p>
<p>The following groups of variables can be accessed or set as a vector ordered by the joint indexes / names:</p>
<ul>
<li><code>get_positions()</code>, <code>set_positions({...})</code> in radians</li>
<li><code>get_velocities()</code>, <code>set_velocities({...})</code> in radians per second</li>
<li><code>get_accelerations()</code>, <code>set_accelerations({...})</code> in radians per second squared</li>
<li><code>get_torques()</code>, <code>set_torques({...})</code> in Newton-meters</li>
</ul>
<p>The vector setters are defined for both <code>Eigen::VectorXd</code> and <code>std::vector&lt;double&gt;</code>:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js(<span class="stringliteral">&quot;my_robot&quot;</span>, 3);</div>
<div class="line">js.set_positions(Eigen::Vector3d(.5, 1., 0.));</div>
<div class="line">js.set_positions(std::vector&lt;double&gt;{.5, 1., 0.});</div>
</div><!-- fragment --><p>When setting a vector of state variables, the size of the input vector must match the number of joints.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">js.set_positions(Eigen::Vector4d::Random()); <span class="comment">// will throw an IncompatibleSizeException</span></div>
</div><!-- fragment --><p>The state variable values of each individual joint can also be accessed as scalars, using either the integer joint index or the string joint name as the identifier:</p>
<ul>
<li><code>get_position(id)</code>, <code>set_position(x, id)</code> in radians</li>
<li><code>get_velocity(id)</code>, <code>set_velocity(x, id)</code> in radians per second</li>
<li><code>get_acceleration(id)</code>, <code>set_acceleration(x, id)</code> in radians per second squared</li>
<li><code>get_torque(id)</code>, <code>set_torques(x, id)</code> in Newton-meters</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> js = <a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a2939ab85acce8605260589f376d4ffa9">state_representation::JointState::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, { <span class="stringliteral">&quot;hip&quot;</span>, <span class="stringliteral">&quot;knee&quot;</span> });</div>
<div class="line"> </div>
<div class="line">js.<a class="code hl_function" href="classstate__representation_1_1_joint_state.html#ae1f9c407ff03b9fcf5306ddea142efca">get_position</a>(0); <span class="comment">// get the position of the hip joint</span></div>
<div class="line">js.get_velocity(<span class="stringliteral">&quot;hip&quot;</span>); <span class="comment">// get the velocity of the hip joint</span></div>
<div class="line">js.set_acceleration(0.5, 1); <span class="comment">// set the acceleration of the knee joint to 5 rad/s^2</span></div>
<div class="line">js.set_torque(2.0, <span class="stringliteral">&quot;knee&quot;</span>); <span class="comment">// set the torque of the knee joint to 2 Nm</span></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html_ae1f9c407ff03b9fcf5306ddea142efca"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html#ae1f9c407ff03b9fcf5306ddea142efca">state_representation::JointState::get_position</a></div><div class="ttdeci">double get_position(const std::string &amp;joint_name) const</div><div class="ttdoc">Get the position of a joint by its name, if it exists.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8cpp_source.html#l00135">JointState.cpp:135</a></div></div>
</div><!-- fragment --><h2>Joint state addition, subtraction and scaling</h2>
<p>Two <code>JointState</code> objects can be combined with addition or subtraction, provided they have the same name and joint names.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js1(<span class="stringliteral">&quot;myrobot&quot;</span>, 3);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> js2(<span class="stringliteral">&quot;myrobot&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// for those operation to be valid both js1 and js2 must have the same name and matching joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> jssum = js1 + js2;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> jsdiff = js1 - js2;</div>
</div><!-- fragment --><p>For all state variables, the result of the operation is applied to each state variable element-wise. For example, if <code>js1</code> has joint positions <code>(x1, x2, x3)</code> and <code>js2</code> has joint positions <code>(y1, y2, y3)</code>, then <code>js1</code> + <code>js2</code> has joint positions <code>(x1 + y1, x2 + y2, x3 + y3)</code>. The same applies for subtraction and is true for all state variable vectors.</p>
<p>A <code>JointState</code> can also be multiplied or divided by a scalar to scale each state variable element-wise.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> double_state = 2.0 * js1;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">state_representation::JointState</a> half_state = js1 / 2.0;</div>
</div><!-- fragment --><h1>Derived joint state classes</h1>
<p>The <code>JointState</code> class contains all spatial and dynamic state variables of a joint collection. In some cases, it is convenient to operate only with specific state variables. The following derived classes are defined:</p>
<ul>
<li><code>JointPositions</code></li>
<li><code>JointVelocities</code></li>
<li><code>JointAccelerations</code></li>
<li><code>JointTorques</code></li>
</ul>
<h2>Joint positions</h2>
<p>The <code>JointPositions</code> class defines only the positions of joints.</p>
<p>In addition to the constructors inherited from <code>JointState</code>, it can be constructed with a vector of initial positions.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::VectorXd initial_positions(3);</div>
<div class="line">initial_positions &lt;&lt; 1.0, 2.0, 3.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a 3-axis robot with initial positions and default joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, initial_positions);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// assign joint names alongside the initial positions</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, { <span class="stringliteral">&quot;shoulder&quot;</span>, <span class="stringliteral">&quot;elbow&quot;</span>, <span class="stringliteral">&quot;wrist&quot;</span> }, initial_positions);</div>
<div class="ttc" id="aclassstate__representation_1_1_joint_positions_html"><div class="ttname"><a href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a></div><div class="ttdoc">Class to define positions of the joints.</div><div class="ttdef"><b>Definition</b> <a href="_joint_positions_8hpp_source.html#l00018">JointPositions.hpp:18</a></div></div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>JointPositions</code> and <code>JointState</code>, provided that they are compatible.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> r1 = joint_positions + other_joint_positions;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r2 = joint_positions + joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r3 = joint_state + joint_positions;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_positions.html">JointPositions</a> r4 = joint_positions - other_joint_positions;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r5 = joint_positions - joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r6 = joint_state - joint_positions;</div>
<div class="line"> </div>
<div class="line">joint_positions += other_joint_positions; <span class="comment">// equivalent to joint_positions = joint_positions + other_joint_positions</span></div>
<div class="line">joint_positions += joint_state; <span class="comment">// equivalent to joint_positions = joint_positions + joint_state</span></div>
<div class="line"> </div>
<div class="line">joint_positions -= other_joint_positions;</div>
<div class="line">joint_positions -= joint_state;</div>
</div><!-- fragment --><p>The time derivative of <code>JointPositions</code> are <code>JointVelocities</code>. The angular displacement of the joints can be converted into angular velocity through division by a time period.</p>
<p>Operations with time use <code>std::chrono::duration</code> types, such as <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>, or definitions with <code>std::literals::chrono_literals</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// take a robot with a displacement of 1 radian around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a> positions(<span class="stringliteral">&quot;my_robot&quot;</span>, Eigen::Vector3d(1, 0, 0));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a 2 second time duration</span></div>
<div class="line">std::chrono::seconds dt(2);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// dividing position by time yields an angular velocity 0.5 radians per second around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> velocities = positions / dt;</div>
<div class="line">velocities.<a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a3ddb20484d1c3b86dc6482f34189abb8">get_velocities</a>(); <span class="comment">// (0.5, 0, 0)</span></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html_a3ddb20484d1c3b86dc6482f34189abb8"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html#a3ddb20484d1c3b86dc6482f34189abb8">state_representation::JointState::get_velocities</a></div><div class="ttdeci">const Eigen::VectorXd &amp; get_velocities() const</div><div class="ttdoc">Getter of the velocities attribute.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8cpp_source.html#l00145">JointState.cpp:145</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_velocities_html"><div class="ttname"><a href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a></div><div class="ttdoc">Class to define velocities of the joints.</div><div class="ttdef"><b>Definition</b> <a href="_joint_velocities_8hpp_source.html#l00018">JointVelocities.hpp:18</a></div></div>
</div><!-- fragment --><h2>Joint velocities</h2>
<p>The <code>JointVelocities</code> class defines only the velocities of joints.</p>
<p>In addition to the constructors inherited from <code>JointState</code>, it can be constructed with a vector of initial velocities:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::VectorXd initial_velocities(3);</div>
<div class="line">initial_velocities &lt;&lt; 1.0, 2.0, 3.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a 3-axis robot with initial velocities and default joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, initial_velocities);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// assign joint names alongside the initial velocities</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, { <span class="stringliteral">&quot;shoulder&quot;</span>, <span class="stringliteral">&quot;elbow&quot;</span>, <span class="stringliteral">&quot;wrist&quot;</span> }, initial_velocities);</div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>JointVelocities</code> and <code>JointState</code>, provided that they are compatible.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> r1 = joint_velocities + other_joint_velocities;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r2 = joint_velocities + joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r3 = joint_state + joint_velocities;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">JointVelocities</a> r4 = joint_velocities - other_joint_velocities;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r5 = joint_velocities - joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r6 = joint_state - joint_velocities;</div>
<div class="line"> </div>
<div class="line">joint_velocities += other_joint_velocities; <span class="comment">// equivalent to joint_velocities = joint_velocities + other_joint_velocities</span></div>
<div class="line">joint_velocities += joint_state; <span class="comment">// equivalent to joint_velocities = joint_velocities + joint_state</span></div>
<div class="line"> </div>
<div class="line">joint_velocities -= other_joint_velocities;</div>
<div class="line">joint_velocities -= joint_state;</div>
</div><!-- fragment --><p>The time derivative of <code>JointVelocities</code> are <code>JointAccelerations</code>. The angular velocity of the joints can be converted into angular acceleration through division by a time period.</p>
<p>Similarly, the time integral of <code>JointVelocities</code> are <code>JointPositions</code>. The angular velocity of the joints can be converted into an angular displacement through multiplication by a time period.</p>
<p>Operations with time use <code>std::chrono::duration</code> types, such as <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>, or definitions with <code>std::literals::chrono_literals</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// take a robot with an angular velocity of 1 radian per second around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> velocities(<span class="stringliteral">&quot;my_robot&quot;</span>, Eigen::Vector3d(1, 0, 0));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a 0.5 second time duration</span></div>
<div class="line">std::chrono::milliseconds dt(500);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// dividing velocity by time yields an angular acceleration 2 radians per second squared around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_accelerations.html">state_representation::JointAccelerations</a> accelerations = velocities / dt;</div>
<div class="line">accelerations.<a class="code hl_function" href="classstate__representation_1_1_joint_state.html#abc910c37f665e0af2da148d1ec69e642">get_accelerations</a>(); <span class="comment">// (2, 0, 0)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// multiplying velocity by time yields joint positions with a displacement of 0.5 radians around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_positions.html">state_representation::JointPositions</a> positions = velocities * dt;</div>
<div class="line">positions.<a class="code hl_function" href="classstate__representation_1_1_joint_state.html#af052d9aa729cf8c19eb906ba27c64b1c">get_positions</a>(); <span class="comment">// (0.5, 0, 0)</span></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_accelerations_html"><div class="ttname"><a href="classstate__representation_1_1_joint_accelerations.html">state_representation::JointAccelerations</a></div><div class="ttdoc">Class to define accelerations of the joints.</div><div class="ttdef"><b>Definition</b> <a href="_joint_accelerations_8hpp_source.html#l00018">JointAccelerations.hpp:18</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html_abc910c37f665e0af2da148d1ec69e642"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html#abc910c37f665e0af2da148d1ec69e642">state_representation::JointState::get_accelerations</a></div><div class="ttdeci">const Eigen::VectorXd &amp; get_accelerations() const</div><div class="ttdoc">Getter of the accelerations attribute.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8cpp_source.html#l00160">JointState.cpp:160</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_state_html_af052d9aa729cf8c19eb906ba27c64b1c"><div class="ttname"><a href="classstate__representation_1_1_joint_state.html#af052d9aa729cf8c19eb906ba27c64b1c">state_representation::JointState::get_positions</a></div><div class="ttdeci">const Eigen::VectorXd &amp; get_positions() const</div><div class="ttdoc">Getter of the positions attribute.</div><div class="ttdef"><b>Definition</b> <a href="_joint_state_8cpp_source.html#l00130">JointState.cpp:130</a></div></div>
</div><!-- fragment --><p>Note that the result of the integration is the displacement from an initial (zero) position. To offset the integration, simply add initial joint positions with the same name and joint names.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// add initial positions to offset the integration </span></div>
<div class="line">positions = initial_positions + velocities * dt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// joint positions can also be updated through a continuous integration of joint velocities</span></div>
<div class="line">positions += velocities * dt;</div>
</div><!-- fragment --><h2>Joint accelerations</h2>
<p>The <code>JointAccelerations</code> class defines only the accelerations of joints.</p>
<p>In addition to the constructors inherited from <code>JointState</code>, it can be constructed with a vector of initial accelerations:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::VectorXd initial_accelerations(3);</div>
<div class="line">initial_accelerations &lt;&lt; 1.0, 2.0, 3.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a 3-axis robot with initial accelerations and default joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_accelerations.html">state_representation::JointAccelerations</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, initial_accelerations);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// assign joint names alongside the initial accelerations</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_accelerations.html">state_representation::JointAccelerations</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, { <span class="stringliteral">&quot;shoulder&quot;</span>, <span class="stringliteral">&quot;elbow&quot;</span>, <span class="stringliteral">&quot;wrist&quot;</span> }, initial_accelerations);</div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>JointAccelerations</code> and <code>JointState</code>, provided that they are compatible.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_accelerations.html">JointAccelerations</a> r1 = joint_accelerations + other_joint_accelerations;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r2 = joint_accelerations + joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r3 = joint_state + joint_accelerations;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_accelerations.html">JointAccelerations</a> r4 = joint_accelerations - other_joint_accelerations;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r5 = joint_accelerations - joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r6 = joint_state - joint_accelerations;</div>
<div class="line"> </div>
<div class="line">joint_accelerations += other_joint_accelerations; <span class="comment">// equivalent to joint_accelerations = joint_accelerations + other_joint_accelerations</span></div>
<div class="line">joint_accelerations += joint_state; <span class="comment">// equivalent to joint_accelerations = joint_accelerations + joint_state</span></div>
<div class="line"> </div>
<div class="line">joint_accelerations -= other_joint_accelerations;</div>
<div class="line">joint_accelerations -= joint_state;</div>
</div><!-- fragment --><p>The time integral of <code>JointAccelerations</code> are <code>JointVelocities</code>. The angular acceleration of the joints can be converted into an angular velocities through multiplication by a time period.</p>
<p>Operations with time use <code>std::chrono::duration</code> types, such as <code>std::chrono::milliseconds</code>, <code>std::chrono::seconds</code>, or definitions with <code>std::literals::chrono_literals</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// take a robot with an angular acceleration of 1 radian per second squared around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_accelerations.html">state_representation::JointAccelerations</a> accelerations(<span class="stringliteral">&quot;my_robot&quot;</span>, Eigen::Vector3d(1, 0, 0));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// define a 0.5 second time duration</span></div>
<div class="line">std::chrono::milliseconds dt(500);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// multiplying acceleration by time yields an angular velocity of 0.5 radians around the first joint</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> velocities = accelerations * dt;</div>
<div class="line">velocities.<a class="code hl_function" href="classstate__representation_1_1_joint_state.html#a3ddb20484d1c3b86dc6482f34189abb8">get_velocities</a>(); <span class="comment">// (0.5, 0, 0)</span></div>
</div><!-- fragment --><p>Note that the result of the integration assumes zero initial joint velocities. To offset the integration, simply add initial joint velocities with the same name and joint names.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// add initial velocities to offset the integration </span></div>
<div class="line">velocities = initial_velocities + accelerations * dt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// joint velocities can also be updated through a continuous integration of joint accelerations</span></div>
<div class="line">velocities += accelerations * dt;</div>
</div><!-- fragment --><h2>Joint torques</h2>
<p>The <code>JointTorques</code> class defines only the torques of joints.</p>
<p>In addition to the constructors inherited from <code>JointState</code>, it can be constructed with a vector of initial torques.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Eigen::VectorXd initial_torques(3);</div>
<div class="line">initial_torques &lt;&lt; 1.0, 2.0, 3.0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a 3-axis robot with initial torques and default joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_torques.html">state_representation::JointTorques</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, initial_torques);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// assign joint names alongside the initial torques</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_torques.html">state_representation::JointTorques</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, { <span class="stringliteral">&quot;shoulder&quot;</span>, <span class="stringliteral">&quot;elbow&quot;</span>, <span class="stringliteral">&quot;wrist&quot;</span> }, initial_torques);</div>
<div class="ttc" id="aclassstate__representation_1_1_joint_torques_html"><div class="ttname"><a href="classstate__representation_1_1_joint_torques.html">state_representation::JointTorques</a></div><div class="ttdoc">Class to define torques of the joints.</div><div class="ttdef"><b>Definition</b> <a href="_joint_torques_8hpp_source.html#l00018">JointTorques.hpp:18</a></div></div>
</div><!-- fragment --><p>Addition and subtraction is supported between <code>JointTorques</code> and <code>JointState</code>, provided that they are compatible.</p>
<p>The return type of each compatible operation is shown below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> r1 = joint_torques + other_joint_torques;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r2 = joint_torques + joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r3 = joint_state + joint_torques;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_torques.html">JointTorques</a> r4 = joint_torques - other_joint_torques;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r5 = joint_torques - joint_state;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_state.html">JointState</a> r6 = joint_state - joint_torques;</div>
<div class="line"> </div>
<div class="line">joint_torques += other_joint_torques; <span class="comment">// equivalent to joint_torques = joint_torques + other_joint_torques</span></div>
<div class="line">joint_torques += joint_state; <span class="comment">// equivalent to joint_torques = joint_torques + joint_state</span></div>
<div class="line"> </div>
<div class="line">joint_torques -= other_joint_torques;</div>
<div class="line">joint_torques -= joint_state;</div>
</div><!-- fragment --><h1>Jacobian</h1>
<p>In robotics, the Jacobian is used to map state variables between joint space and Cartesian space. Mathematically, it is a matrix containing the set of partial derivatives for a vector function.</p>
<p>Most commonly, it is used to convert joint velocities of a robot into the Cartesian velocity of the end-effector. Conversely, the transpose can map a Cartesian wrench applied at the end-effector to the associated torques at each joint. The Jacobian matrix has additional uses for inverse kinematics and null-space control.</p>
<p>The <code>Jacobian</code> class is a wrapper for the underlying matrix that works directly with <code>JointState</code> and <code>CartesianState</code> types while providing additional methods and operators.</p>
<h2>Reference frame and joint names</h2>
<p>Because the <code>Jacobian</code> class is designed to map state between joint and Cartesian space, it shares the properties of both <code>JointState</code> and <code>CartesianState</code>; the accessor methods are listed below:</p>
<ul>
<li><code>get_name()</code> returns the "robot name", i.e. the name of the corresponding <code>JointState</code></li>
<li><code>get_frame()</code> returns the end-effector frame name, i.e. the name of the corresponding <code>CartesianState</code></li>
<li><code>get_joint_names()</code> returns the vector of joint names of the corresponding <code>JointState</code></li>
<li><code>get_reference_frame()</code> returns the reference frame of the corresponding <code>CartesianState</code></li>
</ul>
<p>Each property is initialized on construction and has a corresponding setter for post-construction modifications.</p>
<h3 id="jacobian-construction">Construction</h3>
<p><code>Jacobian</code> constructors take a name, a number of joints or optional vector of joint names, a frame name and an optional reference frame. As with <code>JointState</code>, joint names are default initialized based on their index, starting from 0: <code>{"joint0", "joint1", ..., "jointX"}</code>. As with <code>CartesianState</code>, the reference frame is "world" by default.</p>
<p>Constructing a <code>Jacobian</code> without any data results in an empty state. The initial data can be set from an <code>Eigen::MatrixXd</code> matrix of size <code>6 x N</code>, where <code>N</code> is the number of joints. Alternatively, the <code>Random()</code> static constructor can be used, which sets all matrix elements to a unit random state within a uniform distribution.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with end-effector frame &quot;A&quot; expressed in &quot;world&quot; (default)</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j1(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">j1.get_joint_names(); <span class="comment">// {&quot;joint0&quot;, &quot;joint1&quot;, &quot;joint2&quot;}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// the reference frame can be supplied to any constructor as the last argument:</span></div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with end-effector &quot;A&quot; expressed in &quot;B&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with specific joint names and end-effector frame &quot;A&quot; expressed in &quot;world&quot;</span></div>
<div class="line">std::vector&lt;std::string&gt; joint_names = { <span class="stringliteral">&quot;shoulder&quot;</span>, <span class="stringliteral">&quot;elbow&quot;</span>, <span class="stringliteral">&quot;wrist&quot;</span> };</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j2(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">j2.get_joint_names(); <span class="comment">// {&quot;shoulder&quot;, &quot;elbow&quot;, &quot;wrist&quot;}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// same as above but in reference frame &quot;B&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j2(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> data = Eigen::MatrixXd::Zero(6, 3);</div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with end-effector frame &quot;A&quot; with specific data matrix and default joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, data); <span class="comment">// expressed in &quot;world&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, data, <span class="stringliteral">&quot;B&quot;</span>); <span class="comment">// expressed in reference frame &quot;B&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with end-effector frame &quot;A&quot; with specific data matrix and custom joint names</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names, <span class="stringliteral">&quot;A&quot;</span>, data); <span class="comment">// expressed in &quot;world&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names, <span class="stringliteral">&quot;A&quot;</span>, data, <span class="stringliteral">&quot;B&quot;</span>); <span class="comment">// expressed in reference frame &quot;B&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with end-effector frame &quot;A&quot; with random data matrix and default joint names</span></div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>); <span class="comment">// expressed in &quot;world&quot;</span></div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>); <span class="comment">// expressed in reference frame &quot;B&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3-axis robot &quot;my_robot&quot; with end-effector frame &quot;A&quot; with random data matrix and custom joint names</span></div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names, <span class="stringliteral">&quot;A&quot;</span>); <span class="comment">// expressed in &quot;world&quot;</span></div>
<div class="line"><a class="code hl_function" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, joint_names, <span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>); <span class="comment">// expressed in reference frame &quot;B&quot;</span></div>
<div class="ttc" id="aclassstate__representation_1_1_jacobian_html"><div class="ttname"><a href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a></div><div class="ttdoc">Class to define a robot Jacobian matrix.</div><div class="ttdef"><b>Definition</b> <a href="_jacobian_8hpp_source.html#l00021">Jacobian.hpp:21</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_jacobian_html_af91b214006a9f88862c39a21dc92dd3d"><div class="ttname"><a href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a></div><div class="ttdeci">static Jacobian Random(const std::string &amp;robot_name, unsigned int nb_joints, const std::string &amp;frame, const std::string &amp;reference_frame=&quot;world&quot;)</div><div class="ttdoc">Constructor for a random Jacobian.</div><div class="ttdef"><b>Definition</b> <a href="_jacobian_8cpp_source.html#l00066">Jacobian.cpp:66</a></div></div>
</div><!-- fragment --><h3>Construction from robot model</h3>
<p>A <code>Jacobian</code> that accurately maps from joint space to Cartesian space depends on the structure of the robot (the spatial offset between each joint) in addition to the current joint positions. Advanced users may calculate or supply the matrix manually using the appropriate constructor or data setters. The easiest way to construct an accurate <code>Jacobian</code> is to use the <code><a class="el" href="classrobot__model_1_1_model.html" title="The Model class is a wrapper around pinocchio dynamic computation library with state_representation e...">robot_model::Model</a></code> class. See the documentation of the <code><a class="el" href="namespacerobot__model.html" title="Robot kinematics and dynamics.">robot_model</a></code> module for more details; an example is given below.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classrobot__model_1_1_model.html">robot_model::Model</a> robot(<span class="stringliteral">&quot;my_robot&quot;</span>, <span class="stringliteral">&quot;/examples/my_robot.urdf&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> joint_positions = <a class="code hl_function" href="classstate__representation_1_1_joint_positions.html#aa57ddca4ebb17ec9b867e29acf2a63cc">state_representation::JointPositions::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, robot.get_joint_frames());</div>
<div class="line"><span class="keyword">auto</span> jacobian = model.compute_jacobian(joint_positions);</div>
<div class="ttc" id="aclassrobot__model_1_1_model_html"><div class="ttname"><a href="classrobot__model_1_1_model.html">robot_model::Model</a></div><div class="ttdoc">The Model class is a wrapper around pinocchio dynamic computation library with state_representation e...</div><div class="ttdef"><b>Definition</b> <a href="_model_8hpp_source.html#l00052">Model.hpp:52</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_joint_positions_html_aa57ddca4ebb17ec9b867e29acf2a63cc"><div class="ttname"><a href="classstate__representation_1_1_joint_positions.html#aa57ddca4ebb17ec9b867e29acf2a63cc">state_representation::JointPositions::Random</a></div><div class="ttdeci">static JointPositions Random(const std::string &amp;robot_name, unsigned int nb_joints)</div><div class="ttdoc">Constructor for random joint positions.</div><div class="ttdef"><b>Definition</b> <a href="_joint_positions_8cpp_source.html#l00058">JointPositions.cpp:58</a></div></div>
</div><!-- fragment --><h2>Jacobian matrix operations</h2>
<p>The <code>Jacobian</code> type is a wrapper for matrix data of type <code>Eigen::MatrixXd</code>. The matrix always has 6 rows, corresponding to the 6 Cartesian degrees of freedom (linear X, Y, Z and angular X, Y, Z, in that order). The matrix has a number of columns corresponding to the number of joints; a 3-axis robot will have a <code>6 x 3</code> Jacobian matrix while a 6-axis robot will have a square <code>6 x 6</code> matrix.</p>
<p>The <code>data()</code> method returns the underlying matrix, while <code>set_data()</code> can be used to overwrite the matrix. When setting the data on a previously constructed <code>Jacobian</code>, the matrix must have the correct size.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacobian(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">jacobian.set_data(Eigen::MatrixXd::Random(6, 3)); </div>
<div class="line"> </div>
<div class="line"><span class="comment">// an IncompatibleSizeException will be thrown if the size is not correct</span></div>
<div class="line">jacobian.set_data(Eigen::MatrixXd::Random(6, 4)); <span class="comment">// error!</span></div>
<div class="line">jacobian.set_data(Eigen::MatrixXd::Random(5, 3)); <span class="comment">// error!</span></div>
</div><!-- fragment --><p>Variants of the matrix such as the transpose or inverse can be accessed with the following methods.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j3(<span class="stringliteral">&quot;3_axis_robot&quot;</span>, 3, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j6(<span class="stringliteral">&quot;6_axis_robot&quot;</span>, 6, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"> </div>
<div class="line">Eigen::MatrixXd jT = j3.transpose();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// for a square Jacobian, returns the inverted matrix</span></div>
<div class="line">Eigen::MatrixXd j_inv = j6.inverse();</div>
<div class="line">j3.inverse(); <span class="comment">// throws an IncompatibleSizeException as non-square matrices are not directly invertible</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// for non-square Jacobians, use the pseudo-inverse instead</span></div>
<div class="line">Eigen::MatrixXd j_pinv = j3.pseudoinverse();</div>
</div><!-- fragment --><h2>JointVelocities to CartesianTwist</h2>
<p>To transform <code>JointVelocities</code> into a <code>CartesiantTwist</code>, simply multiply the <code>Jacobian</code> by the <code>JointVelocities</code>.</p>
<p>For the transformation to be valid, the Jacobian matrix data must be set according to the current robot configuration. See also the section Construction from robot model. In addition, the <code>JointVelocites</code> must be compatible with the <code>Jacobian</code>, with the same name, number of joints and joint names.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacobian(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line">jacobian.set_data(...); <span class="comment">// set the Jacobian data matrix for the current robot configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// get joint velocities for the same robot</span></div>
<div class="line"><span class="keyword">auto</span> joint_velocities = <a class="code hl_function" href="classstate__representation_1_1_joint_velocities.html#a11272fd877a70a0dd808c47896c14f13">state_representation::JointVelocities::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// compute the twist of the &quot;end_effector&quot; frame expressed in &quot;base_frame&quot;</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> end_effector_twist = jacobian * joint_velocities;</div>
<div class="ttc" id="aclassstate__representation_1_1_joint_velocities_html_a11272fd877a70a0dd808c47896c14f13"><div class="ttname"><a href="classstate__representation_1_1_joint_velocities.html#a11272fd877a70a0dd808c47896c14f13">state_representation::JointVelocities::Random</a></div><div class="ttdeci">static JointVelocities Random(const std::string &amp;robot_name, unsigned int nb_joints)</div><div class="ttdoc">Constructor for random joint velocities.</div><div class="ttdef"><b>Definition</b> <a href="_joint_velocities_8cpp_source.html#l00060">JointVelocities.cpp:60</a></div></div>
</div><!-- fragment --><h2>CartesianTwist to JointVelocities</h2>
<p>The transformation from <code>CartesianTwist</code> to <code>JointVelocities</code> requires the inverse of the Jacobian matrix (or, in the case of non-square matrices, the pseudo-inverse).</p>
<p>One approach is to use the matrix results of the <code>inverse()</code> or <code>pseudoinverse()</code> methods and multiply them directly with data vectors.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j3(<span class="stringliteral">&quot;3_axis_robot&quot;</span>, 3, <span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> j6(<span class="stringliteral">&quot;6_axis_robot&quot;</span>, 6, <span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line">j3.set_data(...); <span class="comment">// set the 6 x 3 Jacobian data matrix for the current robot configuration</span></div>
<div class="line">j6.set_data(...); <span class="comment">// set the 6 x 6 Jacobian data matrix for the current robot configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> raw_end_effector_twist = Eigen::VectorXd::Random(3);</div>
<div class="line">Eigen::VectorXd raw_joint_velocities = j3.pseudoinverse() * raw_end_effector_twist; <span class="comment">// vector of 3 joint velocities</span></div>
<div class="line"> </div>
<div class="line">raw_end_effector_twist = Eigen::VectorXd::Random(6);</div>
<div class="line">Eigen::VectorXd raw_joint_velocities = j6.inverse() * raw_end_effector_twist; <span class="comment">// vector of 6 joint velocities</span></div>
</div><!-- fragment --><p>However, this approach is not ideal for two reasons; it doesn't operate directly on <code>CartesianTwist</code> and <code>JointVelocities</code> types, and is mathematically inefficient in the case of a square Jacobian (i.e. a 6-axis robot). For the equation <code>W = inv(J) * V</code>, W can be solved for more efficiently by using QR decomposition.</p>
<p>Instead of accessing the transformed matrix and multiplying it by a data vector, instead use the overloaded functions directly with <code>CartesianTwist</code> as illustrated below. Note that the <code>CartesianTwist</code> must be compatible with the <code>Jacobian</code>, with a matching frame and reference frame.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// get the Cartesian twist of the same frame and reference frame</span></div>
<div class="line"><span class="keyword">auto</span> end_effector_twist = <a class="code hl_function" href="classstate__representation_1_1_cartesian_twist.html#a66d6821fbb85857c8917a13576eaa138">state_representation::CartesianTwist::Random</a>(<span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// compute the joint velocities of the 3-axis robot from the Cartesian twist using the pseudo-inverse</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> j3_velocities = j3.pseudoinverse(end_effector_twist);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// compute the joint velocities of the 3-axis robot from the Cartesian twist using the inverse</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> j6_velocities = j6.inverse(end_effector_twist);</div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_twist_html_a66d6821fbb85857c8917a13576eaa138"><div class="ttname"><a href="classstate__representation_1_1_cartesian_twist.html#a66d6821fbb85857c8917a13576eaa138">state_representation::CartesianTwist::Random</a></div><div class="ttdeci">static CartesianTwist Random(const std::string &amp;name, const std::string &amp;reference=&quot;world&quot;)</div><div class="ttdoc">Constructor for a random twist.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_twist_8cpp_source.html#l00060">CartesianTwist.cpp:60</a></div></div>
</div><!-- fragment --><h2>CartesianWrench to JointTorques</h2>
<p>The transformation of a <code>CartesianWrench</code> into <code>JointTorques</code> uses the transpose of the Jacobian matrix.</p>
<p>As with the conversion from CartesianTwist to JointVelocities, the operations can either be done using the matrix result of <code>transpose()</code>, or by providing the <code>CartesianWrench</code> as the input to the overloaded <code>tranpose()</code> function. The latter has the benefit of working directly with the abstract state classes instead of raw data vectors. Note that the <code>CartesianWrench</code> must be compatible with the <code>Jacobian</code>, with a matching frame and reference frame.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacobian(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line">jacobian.set_data(...); <span class="comment">// set the Jacobian data matrix for the current robot configuration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// get the Cartesian wrench of the same frame and reference frame</span></div>
<div class="line"><span class="keyword">auto</span> end_effector_wrench = <a class="code hl_function" href="classstate__representation_1_1_cartesian_twist.html#a66d6821fbb85857c8917a13576eaa138">state_representation::CartesianTwist::Random</a>(<span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// compute the torques of each joint from the Cartesian twist</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_torques.html">state_representation::JointTorques</a> joint_torques = jacobian.transpose(end_effector_wrench);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// the matrix product should only be used on raw data vectors</span></div>
<div class="line">Eigen::VectorXd raw_joint_torques = jacobian.transpose() * end_effector_wrench.get_wrench();</div>
</div><!-- fragment --><h2>Changing the Jacobian reference frame</h2>
<p>Whenever the <code>Jacobian</code> is used to convert between joint and Cartesian space, the Cartesian state variables must be expressed in the same reference frame as the <code>Jacobian</code>. If the <code>Jacobian</code> is expressed in a robot base frame while a <code>CartesianTwist</code> is measured in a world reference frame, then that twist cannot be directly used to find the corresponding joint velocities.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> jacobian = <a class="code hl_function" href="classstate__representation_1_1_jacobian.html#af91b214006a9f88862c39a21dc92dd3d">state_representation::Jacobian::Random</a>(<span class="stringliteral">&quot;my_robot&quot;</span>, 3, <span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;base_frame&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> twist_in_world = <a class="code hl_function" href="classstate__representation_1_1_cartesian_twist.html#a66d6821fbb85857c8917a13576eaa138">state_representation::CartesianTwist::Random</a>(<span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">jacobian.pseudoinverse(twist_in_world); <span class="comment">// error! IncompatibleStatesException</span></div>
</div><!-- fragment --><p>If the transformation between the robot base frame and world is known and expressed as a <code>CartesianPose</code>, it could be used to transform the <code>CartesianTwist</code> relative to the robot base frame (see the section describing Cartesian transforms for more information).</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> pose = <a class="code hl_function" href="classstate__representation_1_1_cartesian_pose.html#aeb83b9e4a6e9fba8f8d7651696f1ec24">state_representation::CartesianPose::Random</a>(<span class="stringliteral">&quot;base_frame&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> twist_in_base_frame = pose.<a class="code hl_function" href="classstate__representation_1_1_cartesian_pose.html#ae5920caed434f02897d01cc65b7d7cfc">inverse</a>() * twist_in_world;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> joint_velocities = jacobian.pseudoinverse(twist_in_base_frame);</div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_pose_html_ae5920caed434f02897d01cc65b7d7cfc"><div class="ttname"><a href="classstate__representation_1_1_cartesian_pose.html#ae5920caed434f02897d01cc65b7d7cfc">state_representation::CartesianPose::inverse</a></div><div class="ttdeci">CartesianPose inverse() const</div><div class="ttdoc">Compute the inverse of the current Cartesian pose.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_pose_8cpp_source.html#l00087">CartesianPose.cpp:87</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_pose_html_aeb83b9e4a6e9fba8f8d7651696f1ec24"><div class="ttname"><a href="classstate__representation_1_1_cartesian_pose.html#aeb83b9e4a6e9fba8f8d7651696f1ec24">state_representation::CartesianPose::Random</a></div><div class="ttdeci">static CartesianPose Random(const std::string &amp;name, const std::string &amp;reference=&quot;world&quot;)</div><div class="ttdoc">Constructor for a random pose.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_pose_8cpp_source.html#l00062">CartesianPose.cpp:62</a></div></div>
</div><!-- fragment --><p>This can also be applied to the reverse case:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> recalculated_twist_in_base_frame = jacobian * joint_velocities;</div>
<div class="line"><span class="keyword">auto</span> recalculated_twist_in_world = pose * recalculated_twist_in_base_frame;</div>
</div><!-- fragment --><p>However, transforming the Cartesian state variables before and after manipulation with the <code>Jacobian</code> can be inefficient. Consider the case of high-frequency sensor data measured in a different reference frame needing to be transformed before every Jacobian operation.</p>
<p>Instead, a <code>CartesianPose</code> can be used to change the reference frame of the <code>Jacobian</code> through a corresponding linear transformation of the underlying data matrix. As a result, previously incompatible operations automatically work in the new reference frame.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_jacobian.html">state_representation::Jacobian</a> jacobian_in_world = pose * jacobian;</div>
<div class="line">jacobian.<a class="code hl_function" href="classstate__representation_1_1_spatial_state.html#ad5918d6279f226d9ccb2f2f50d6ce321">get_reference_frame</a>(); <span class="comment">// world</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_joint_velocities.html">state_representation::JointVelocities</a> joint_velocities = jacobian_in_world.<a class="code hl_function" href="classstate__representation_1_1_jacobian.html#a2d05a9d5b84b11e2bc791bfaf1be3204">pseudoinverse</a>(twist_in_world);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> recalculated_twist_in_world = jacobian_in_world * joint_velocities;</div>
<div class="ttc" id="aclassstate__representation_1_1_jacobian_html_a2d05a9d5b84b11e2bc791bfaf1be3204"><div class="ttname"><a href="classstate__representation_1_1_jacobian.html#a2d05a9d5b84b11e2bc791bfaf1be3204">state_representation::Jacobian::pseudoinverse</a></div><div class="ttdeci">Eigen::MatrixXd pseudoinverse() const</div><div class="ttdoc">Return the pseudoinverse of the Jacobian matrix.</div><div class="ttdef"><b>Definition</b> <a href="_jacobian_8cpp_source.html#l00245">Jacobian.cpp:245</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_spatial_state_html_ad5918d6279f226d9ccb2f2f50d6ce321"><div class="ttname"><a href="classstate__representation_1_1_spatial_state.html#ad5918d6279f226d9ccb2f2f50d6ce321">state_representation::SpatialState::get_reference_frame</a></div><div class="ttdeci">const std::string &amp; get_reference_frame() const</div><div class="ttdoc">Getter of the reference frame as const reference.</div><div class="ttdef"><b>Definition</b> <a href="_spatial_state_8cpp_source.html#l00026">SpatialState.cpp:26</a></div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
