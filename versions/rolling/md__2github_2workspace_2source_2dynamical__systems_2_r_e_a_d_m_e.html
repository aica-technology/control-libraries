<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Control Libraries: Dynamical Systems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Control Libraries<span id="projectnumber">&#160;9.2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Dynamical Systems</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This library provides a set of classes to represent <b>Dynamical Systems</b>: functions which map a state to a state derivative.</p>
<p>All controllers have a common interface inheriting from the <code>IDynamicalSystem&lt;S&gt;</code> class, which is templated to operate in a particular space <code>S</code>, namely Cartesian or joint space.</p>
<h1>Table of contents:</h1>
<ul>
<li>Constructing a dynamical system</li>
<li>Using a dynamical system<ul>
<li>Parameters</li>
<li>Evaluate</li>
</ul>
</li>
<li>Developing a new dynamical system</li>
<li>About<ul>
<li>Base frame</li>
<li>Reference frames</li>
</ul>
</li>
<li>Point attractor<ul>
<li>Configuring the Linear DS</li>
<li>Evaluating the Linear DS</li>
</ul>
</li>
<li>Circular<ul>
<li>Configuring the Circular DS</li>
</ul>
</li>
<li>Ring<ul>
<li>Configuring the Ring DS</li>
</ul>
</li>
</ul>
<h1>Constructing a dynamical system</h1>
<p>The <code>DynamicalSystemFactory&lt;S&gt;</code> provides construction helpers for dynamical systems using a factory pattern. Specific dynamical systems are created and injected into a common <code>shared_ptr&lt;IDynamicalSystem&lt;S&gt;&gt;</code>.</p>
<p>The <code>CartesianDynamicalSystemFactory</code> and <code>JointDynamicalSystemFactory</code> are shortcuts for the Cartesian and joint space dynamical system factories.</p>
<p>The factory provides a static function <code>create_dynamical_system</code>, which can take a number of inputs. The first input argument is always the controller type (defined in <code><a class="el" href="_dynamical_system_type_8hpp_source.html">dynamical_systems/DynamicalSystemType.hpp</a></code>).</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;dynamical_systems/DynamicalSystemFactory.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedynamical__systems.html">dynamical_systems</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacestate__representation.html">state_representation</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a Cartesian dynamical system</span></div>
<div class="line">std::shared_ptr&lt;IDynamicalSystem&lt;CartesianState&gt;&gt; cart_ds;</div>
<div class="line">cart_ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// create a Cartesian dynamical system using &quot;auto&quot; to avoid verbose typing</span></div>
<div class="line"><span class="keyword">auto</span> cart_ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR);</div>
<div class="ttc" id="anamespacedynamical__systems_html"><div class="ttname"><a href="namespacedynamical__systems.html">dynamical_systems</a></div><div class="ttdoc">Systems of equations relating state variables to their derivatives.</div><div class="ttdef"><b>Definition</b> <a href="_circular_8hpp_source.html#l00007">Circular.hpp:7</a></div></div>
<div class="ttc" id="anamespacestate__representation_html"><div class="ttname"><a href="namespacestate__representation.html">state_representation</a></div><div class="ttdoc">Core state variables and objects.</div><div class="ttdef"><b>Definition</b> <a href="_analog_i_o_state_8hpp_source.html#l00005">AnalogIOState.hpp:5</a></div></div>
</div><!-- fragment --><p>Initial dynamical system parameters can be passed to <code>create_dynamical_system</code> as a list. See the next section for more details on parameter configuration.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;dynamical_systems/DynamicalSystemFactory.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;state_representation/parameters/Parameter.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedynamical__systems.html">dynamical_systems</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacestate__representation.html">state_representation</a>;</div>
<div class="line"> </div>
<div class="line">std::list&lt;std::shared_ptr&lt;ParameterInterface&gt;&gt; parameters;</div>
<div class="line">parameters.emplace_back(make_shared_parameter(<span class="stringliteral">&quot;attractor&quot;</span>, CartesianPose::Random(<span class="stringliteral">&quot;target&quot;</span>)));</div>
<div class="line">parameters.emplace_back(make_shared_parameter(<span class="stringliteral">&quot;gain&quot;</span>, 5.0));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> cart_ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR, parameters);</div>
</div><!-- fragment --><h1>Using a dynamical system</h1>
<p>The dynamical system factory returns a base class pointer <code>shared_ptr&lt;IDynamicalSystem&lt;S&gt;&gt;</code> for the chosen state type <code>S</code>, pointing to an instance of a specific derived dynamical system. This allows all dynamical systems to share the same consistent interface for usage and configuration.</p>
<h2>Parameters</h2>
<p>Dynamical systems support custom parametrization through the base interface using <code><a class="el" href="classstate__representation_1_1_parameter_map.html" title="A wrapper class to contain a map of Parameter pointers by name and provide robust access methods.">state_representation::ParameterMap</a></code> methods:</p>
<ul>
<li><code>get_parameters()</code></li>
<li><code>get_parameter(name)</code></li>
<li><code>get_parameter_value&lt;T&gt;(name)</code></li>
<li><code>set_parameters(parameters)</code></li>
<li><code>set_parameter(parameter)</code></li>
<li><code>set_parameter_value(name, value)</code></li>
</ul>
<p>These methods can be used after construction to get or set dynamical system parameters. Refer to the documentation on <code><a class="el" href="classdynamical__systems_1_1_i_dynamical_system.html" title="Abstract class for a dynamical system.">dynamical_systems::IDynamicalSystem</a>&lt;S&gt;</code> and <code><a class="el" href="classstate__representation_1_1_parameter_map.html" title="A wrapper class to contain a map of Parameter pointers by name and provide robust access methods.">state_representation::ParameterMap</a></code> for more information.</p>
<h2>Evaluate</h2>
<p>The main purpose of each dynamical system is the <code>evaluate</code> function, which calculates the state derivative from the current state. For example, the point attractor dynamical system takes the difference between the current pose and the desired pose and multiplies it by a linear gain to compute the desired twist.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &quot;dynamical_systems/DynamicalSystemFactory.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;state_representation/space/cartesian/CartesianPose.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacedynamical__systems.html">dynamical_systems</a>;</div>
<div class="line"> </div>
<div class="line">std::list&lt;std::shared_ptr&lt;ParameterInterface&gt;&gt; parameters;</div>
<div class="line">parameters.emplace_back(make_shared_parameter(<span class="stringliteral">&quot;attractor&quot;</span>, CartesianPose::Random(<span class="stringliteral">&quot;target&quot;</span>)));</div>
<div class="line">parameters.emplace_back(make_shared_parameter(<span class="stringliteral">&quot;gain&quot;</span>, 5.0));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> cart_ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR, parameters);</div>
<div class="line"><span class="keyword">auto</span> current_state = CartesianPose::Random(<span class="stringliteral">&quot;state&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// compute the twist</span></div>
<div class="line"><span class="keyword">auto</span> desired_twist = cart_ds-&gt;evaluate(current_state);</div>
</div><!-- fragment --><h1>Developing a new dynamical system</h1>
<p>To implement a new dynamical system, you need to create a class that derives from the <code>IDynamicalSystem</code> base class or any derived dynamical system such as <code>PointAttractor</code>. This class can be templated to accept different input spaces (e.g. <code>CartesianState</code> or <code>JointState</code>) or specify the desired input state.</p>
<p>The derived dynamical system should override <code>compute_dynamics</code> to produce some custom behaviour. in addition, if the dynamical system has any parameters, you should:</p><ul>
<li>Add parameter pointers as class properties</li>
<li>Initialize and declare parameters in the constructor</li>
<li>Override the <code>is_compatible</code> method, if necessary</li>
<li>Override the protected <code>validate_and_set_parameter</code> method</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// MyCartesianDS.hpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;dynamical_systems/IDynamicalSystem.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;state_representation/space/cartesian/CartesianState.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyCartesianDS : <span class="keyword">public</span> <a class="code hl_class" href="classdynamical__systems_1_1_i_dynamical_system.html">dynamical_systems::IDynamicalSystem</a>&lt;state_representation::CartesianState&gt; {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// initialize and declare parameters</span></div>
<div class="line">  MyCartesianDS();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="comment">// override this method to implement custom logic</span></div>
<div class="line">  <a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> <a class="code hl_function" href="classdynamical__systems_1_1_i_dynamical_system.html#acb7e59ea3a3029997692f385865b6d2f">compute_dynamics</a>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a>&amp; state</div>
<div class="line">  ) <span class="keyword">const override</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// override this method to update dynamical system configurations when a parameter is modified</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classstate__representation_1_1_parameter_map.html#a60130b3a8e2914579dbd96a03810b5b0">validate_and_set_parameter</a>(<span class="keyword">const</span> std::shared_ptr&lt;state_representation::ParameterInterface&gt;&amp; parameter) <span class="keyword">override</span>;</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// add any additional parameters as class properties</span></div>
<div class="line">  std::shared_ptr&lt;state_representation::Parameter&lt;int&gt;&gt; foo_;</div>
<div class="line">  std::shared_ptr&lt;state_representation::Parameter&lt;double&gt;&gt; bar_;</div>
<div class="line">};</div>
<div class="ttc" id="aclassdynamical__systems_1_1_i_dynamical_system_html"><div class="ttname"><a href="classdynamical__systems_1_1_i_dynamical_system.html">dynamical_systems::IDynamicalSystem</a></div><div class="ttdoc">Abstract class for a dynamical system.</div><div class="ttdef"><b>Definition</b> <a href="_i_dynamical_system_8hpp_source.html#l00021">IDynamicalSystem.hpp:21</a></div></div>
<div class="ttc" id="aclassdynamical__systems_1_1_i_dynamical_system_html_acb7e59ea3a3029997692f385865b6d2f"><div class="ttname"><a href="classdynamical__systems_1_1_i_dynamical_system.html#acb7e59ea3a3029997692f385865b6d2f">dynamical_systems::IDynamicalSystem::compute_dynamics</a></div><div class="ttdeci">virtual S compute_dynamics(const S &amp;state) const =0</div><div class="ttdoc">Compute the dynamics of the input state. Internal function, to be redefined based on the type of dyna...</div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a></div><div class="ttdoc">Class to represent a state in Cartesian space.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8hpp_source.html#l00049">CartesianState.hpp:49</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_parameter_map_html_a60130b3a8e2914579dbd96a03810b5b0"><div class="ttname"><a href="classstate__representation_1_1_parameter_map.html#a60130b3a8e2914579dbd96a03810b5b0">state_representation::ParameterMap::validate_and_set_parameter</a></div><div class="ttdeci">virtual void validate_and_set_parameter(const std::shared_ptr&lt; ParameterInterface &gt; &amp;parameter)</div><div class="ttdoc">Validate and set a parameter in the map.</div><div class="ttdef"><b>Definition</b> <a href="_parameter_map_8cpp_source.html#l00067">ParameterMap.cpp:67</a></div></div>
</div><!-- fragment --><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// MyCartesianDS.cpp</span></div>
<div class="line"><span class="preprocessor">#include &quot;MyCartesianDS.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;state_representation/exceptions/InvalidParameterException.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacestate__representation.html">state_representation</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacedynamical__systems.html">dynamical_systems</a> {</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initialize parameters</span></div>
<div class="line">MyCartesianDS::MyCartesianDS() :</div>
<div class="line">    foo_(make_shared_parameter&lt;int&gt;(<span class="stringliteral">&quot;int&quot;</span>, 1)),</div>
<div class="line">    bar_(make_shared_parameter&lt;double&gt;(<span class="stringliteral">&quot;double&quot;</span>, 2.0)) {</div>
<div class="line">  <span class="comment">// &quot;declare&quot; parameters by inserting them into the parameter list with an associated name</span></div>
<div class="line">  this-&gt;parameters_.insert(std::make_pair(<span class="stringliteral">&quot;foo&quot;</span>, foo_));</div>
<div class="line">  this-&gt;parameters_.insert(std::make_pair(<span class="stringliteral">&quot;bar&quot;</span>, bar_));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// implement the command logic</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> MyCartesianDS::compute_dynamics(<span class="keyword">const</span> <a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a>&amp; state)<span class="keyword"> const </span>{</div>
<div class="line">    <a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">CartesianState</a> twist = ...;</div>
<div class="line">    <span class="keywordflow">return</span> twist;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// implement parameter validation</span></div>
<div class="line"><span class="keywordtype">void</span> MyCartesianController::validate_and_set_parameter(</div>
<div class="line">    <span class="keyword">const</span> std::shared_ptr&lt;state_representation::ParameterInterface&gt;&amp; parameter</div>
<div class="line">) {</div>
<div class="line">  <span class="keywordflow">if</span> (parameter-&gt;get_name() == <span class="stringliteral">&quot;foo&quot;</span>) {</div>
<div class="line">    <span class="keyword">auto</span> value = std::static_pointer_cast&lt;state_representation::Parameter&lt;int&gt;&gt;(parameter);</div>
<div class="line">    <span class="comment">// if a parameter value is not supported by the dynamical system, throw an InvalidParameterException</span></div>
<div class="line">    <span class="keywordflow">if</span> (value &lt; 0 || value &gt; 10) {</div>
<div class="line">      <span class="keywordflow">throw</span> <a class="code hl_class" href="classstate__representation_1_1exceptions_1_1_invalid_parameter_exception.html">exceptions::InvalidParameterException</a>(<span class="stringliteral">&quot;Parameter foo must be in range [0 - 10]&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    this-&gt;foo_-&gt;set_value(value);</div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parameter-&gt;get_name() == <span class="stringliteral">&quot;bar&quot;</span>) {</div>
<div class="line">    this-&gt;bar_-&gt;set_value(std::static_pointer_cast&lt;<a class="code hl_class" href="classstate__representation_1_1_parameter.html">state_representation::Parameter&lt;double&gt;</a>&gt;(parameter));</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="ttc" id="aclassstate__representation_1_1_parameter_html"><div class="ttname"><a href="classstate__representation_1_1_parameter.html">state_representation::Parameter</a></div><div class="ttdoc">Class to represent name-value pairs of different types.</div><div class="ttdef"><b>Definition</b> <a href="_parameter_8hpp_source.html#l00018">Parameter.hpp:18</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1exceptions_1_1_invalid_parameter_exception_html"><div class="ttname"><a href="classstate__representation_1_1exceptions_1_1_invalid_parameter_exception.html">state_representation::exceptions::InvalidParameterException</a></div><div class="ttdef"><b>Definition</b> <a href="_invalid_parameter_exception_8hpp_source.html#l00007">InvalidParameterException.hpp:7</a></div></div>
</div><!-- fragment --><h1>About</h1>
<h2>Base frame</h2>
<p>The <code>IDynamicalSystem</code> base class has a private <code>base_frame</code> property, which can be thought of as the DS origin. The functions <code>get_base_frame()</code> and <code>set_base_frame(const S&amp; state)</code> can be used to access or modify this base frame.</p>
<p>Whilst the term <em>base frame</em> makes more sense for a <code>CartesianState</code> DS, it rather refers to a specific robot with corresponding joint names in the case of a <code>JointState</code> DS.</p>
<h2>Reference frames</h2>
<p>The following section applies to derived DS classes using the <code>CartesianState</code> type. The Point Attractor DS will be used as an example.</p>
<p>The <code>evaluate</code> function will always return a twist expressed in the same reference frame as the input state, provided that the input state is compatible with the DS.</p>
<p>The input state must be expressed in one of two supported reference frames:</p><ol type="1">
<li>The reference frame of the input is the DS base frame</li>
<li>The reference frame of the input matches the reference frame of the DS base frame</li>
</ol>
<p>The following snippet illustrates the difference in these two options. </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// create a point attractor DS with attractor B in frame A</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> BinA = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a>(<span class="stringliteral">&quot;B&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR);</div>
<div class="line">ds-&gt;set_attractor_value(<span class="stringliteral">&quot;attractor&quot;</span>, BinA);</div>
<div class="line"> </div>
<div class="line">ds-&gt;get_parameter_value(<span class="stringliteral">&quot;attractor&quot;</span>).get_name();             <span class="comment">// &quot;B&quot;</span></div>
<div class="line">ds-&gt;get_parameter_value(<span class="stringliteral">&quot;attractor&quot;</span>).get_reference_frame();  <span class="comment">// &quot;A&quot;</span></div>
<div class="line">ds-&gt;get_base_frame().get_name();                             <span class="comment">// &quot;A&quot;</span></div>
<div class="line">ds-&gt;get_base_frame().get_reference_frame();                  <span class="comment">// &quot;A&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// evaluate a point C in frame A</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> CinA = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;C&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> twist0 = ds-&gt;evaluate(CinA); <span class="comment">// valid, twist is expressed in frame A</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// set the base from of the DS to be A expressed in the world frame</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> AinWorld = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a>(<span class="stringliteral">&quot;A&quot;</span>, <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line">ds-&gt;set_base_frame(AinWorld);</div>
<div class="line"> </div>
<div class="line">ds-&gt;get_parameter_value(<span class="stringliteral">&quot;attractor&quot;</span>).get_name();             <span class="comment">// &quot;B&quot;</span></div>
<div class="line">ds-&gt;get_parameter_value(<span class="stringliteral">&quot;attractor&quot;</span>).get_reference_frame();  <span class="comment">// &quot;A&quot;</span></div>
<div class="line">ds-&gt;get_base_frame().get_name();                             <span class="comment">// &quot;A&quot;</span></div>
<div class="line">ds-&gt;get_base_frame().get_reference_frame();                  <span class="comment">// &quot;world&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// option 1: reference frame of the input is the same as the base frame </span></div>
<div class="line"><span class="comment">// -&gt; reference frame of the input: &quot;A&quot;</span></div>
<div class="line"><span class="comment">// -&gt; DS base frame: &quot;A&quot;</span></div>
<div class="line"><span class="comment">// -&gt; reference frame of the output: &quot;A&quot;</span></div>
<div class="line"><span class="keyword">auto</span> twist1 = ds-&gt;evaluate(CinA);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// option 2: reference frame of the input is the same as the base frame </span></div>
<div class="line"><span class="comment">// -&gt; reference frame of the input: &quot;world&quot;</span></div>
<div class="line"><span class="comment">// -&gt; DS base frame reference frame: &quot;world&quot;</span></div>
<div class="line"><span class="comment">// -&gt; reference frame of the output: &quot;world&quot;</span></div>
<div class="line"><span class="keyword">auto</span> CinWorld = AinWorld * CinA;</div>
<div class="line"><span class="keyword">auto</span> twist2 = ds-&gt;evaluate(CinWorld);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// as a note, you can mix and match the approach as necessary.</span></div>
<div class="line"><span class="comment">// the following is using option 1 with an additional external operation</span></div>
<div class="line"><span class="comment">// to yield a final result equivalent to option 2.</span></div>
<div class="line"><span class="keyword">auto</span> twist3 =  AinWorld * ds-&gt;evaluate(CinA);</div>
<div class="line"><span class="comment">// twist2 === twist3</span></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a25b526d9023e1c101256faf26eb741e3"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a></div><div class="ttdeci">static CartesianState Random(const std::string &amp;name, const std::string &amp;reference=&quot;world&quot;)</div><div class="ttdoc">Constructor for a random Cartesian state.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00074">CartesianState.cpp:74</a></div></div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_state_html_a6c86224b5fed66d56e17f6772d247b59"><div class="ttname"><a href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a></div><div class="ttdeci">static CartesianState Identity(const std::string &amp;name, const std::string &amp;reference=&quot;world&quot;)</div><div class="ttdoc">Constructor for the identity Cartesian state (identity pose and 0 for the rest)</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_state_8cpp_source.html#l00067">CartesianState.cpp:67</a></div></div>
</div><!-- fragment --><p>Note that the base frame can have its own velocity or other state properties, which are automatically combined with the DS result with respect to the common reference frame.</p>
<p>Setting the base frame of the DS has some benefits. In some cases, the state variable to be evaluated is not directly expressed in the frame of the DS. Similarly, the output twist may need to be expressed in a different reference frame.</p>
<p>As a practical example, consider a case where the state of an end-effector is reported in the reference frame of a robot, while a linear attractor is expressed in some moving task frame. The robot controller expects a twist expressed in the robot frame. By updating the DS base frame with respect to the robot frame, any pre-transformation of the end-effector state or post-transformation of the twist can be avoided.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> EE(<span class="stringliteral">&quot;end_effector&quot;</span>, <span class="stringliteral">&quot;robot&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> attractor = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;attractor&quot;</span>, <span class="stringliteral">&quot;task&quot;</span>);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> taskInRobot(<span class="stringliteral">&quot;task&quot;</span>, <span class="stringliteral">&quot;robot&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR);</div>
<div class="line">ds-&gt;set_attractor_value(<span class="stringliteral">&quot;attractor&quot;</span>, attractor);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// control loop</span></div>
<div class="line"><span class="keywordflow">while</span> (...) {</div>
<div class="line">  <span class="comment">// update the EE state from robot feedback </span></div>
<div class="line">  EE.set_pose(...);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// update the state of the task with respect to the robot (for example, from optitrack)</span></div>
<div class="line">  taskInRobot.set_pose(...);</div>
<div class="line">  taskInRobot.set_linear_velocity(...);</div>
<div class="line">  taskInRobot.set_angular_velocity(...);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// now update the DS base frame</span></div>
<div class="line">  linearDS.set_base_frame(taskInRobot);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// find the twist in the robot reference frame </span></div>
<div class="line">  <span class="comment">// directly from the end-effector position in the robot reference frame</span></div>
<div class="line">  <span class="keyword">auto</span> twist = ds-&gt;evaluate(EE);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// send twist command to controller</span></div>
<div class="line">  update_controller(twist);</div>
<div class="line">}</div>
</div><!-- fragment --><h1>Point Attractor</h1>
<p>The <b>Point Attractor</b> DS generates a velocity that is linearly proportional to the distance of the current state from the attractor. It is currently implemented for the <code>CartesianState</code> and <code>JointState</code> types.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// construction with the DS factory</span></div>
<div class="line"><span class="keyword">auto</span> ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR);</div>
</div><!-- fragment --><h2>Configuring the Point Attractor DS</h2>
<p>The Point Attractor DS has the following core parameters:</p><ul>
<li><b>attractor</b>; the <code>CartesianState</code> or <code>JointState</code> type object defining the attractor pose relative to the DS base frame</li>
<li><b>gain</b>; the proportional gain acting towards the attractor</li>
</ul>
<p>The gain defines the proportionality between a distance unit and a velocity unit, and is internally stored as a square matrix with a size corresponding to the degrees of freedom in the state representation. For example, the <code>CartesianState</code> has six degrees of freedom (XYZ in linear and angular space), while the <code>JointState</code> would have as many degrees of freedom as joints. The gain can be defined as a matrix directly, as a diagonal vector of the appropriate length, or as a scalar (which sets the value along the diagonal elements of the matrix). </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// set a gain (scalar, vector or matrix)</span></div>
<div class="line"><span class="keywordtype">double</span> gain = 10;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;gain&quot;</span>, gain);</div>
<div class="line"><span class="comment">// or</span></div>
<div class="line">std::vector&lt;double&gt; gains = {1, 2, 3, 4, 5, 6};</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;gain&quot;</span>, gain);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// update the attractor</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> csB = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;attractor&quot;</span>, csB);</div>
</div><!-- fragment --><h2>Evaluating the Point Attractor DS</h2>
<p>To get the velocity from a state, simply call the <code>evaluate()</code> function.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">auto</span> ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::POINT_ATTRACTOR);</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> csA = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a>(<span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;attractor&quot;</span>, csA);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> csB = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a25b526d9023e1c101256faf26eb741e3">state_representation::CartesianState::Random</a>(<span class="stringliteral">&quot;B&quot;</span>);</div>
<div class="line"><span class="comment">// note: the return type of evaluate() is a CartesianState, but</span></div>
<div class="line"><span class="comment">// it can be directly assigned to a CartesianTwist because the =operator</span></div>
<div class="line"><span class="comment">// has been defined for that purpose</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a> twist = ds-&gt;evaluate(csB);</div>
<div class="ttc" id="aclassstate__representation_1_1_cartesian_twist_html"><div class="ttname"><a href="classstate__representation_1_1_cartesian_twist.html">state_representation::CartesianTwist</a></div><div class="ttdoc">Class to define twist in Cartesian space as 3D linear and angular velocity vectors.</div><div class="ttdef"><b>Definition</b> <a href="_cartesian_twist_8hpp_source.html#l00018">CartesianTwist.hpp:18</a></div></div>
</div><!-- fragment --><p>The returned velocity will always be expressed in the same reference frame as the input state.</p>
<h1>Circular</h1>
<p>The <b>Circular</b> DS is a limit cycle that rotates around a center point in an elliptical orbit, converging to a desired radius on a plane.</p>
<p>The direction of the rotation is positive around the local Z axis; this appears as a counter-clockwise rotation when viewed from "above".</p>
<p>This DS is defined only for the <code>CartesianState</code> type. In addition, it only acts in linear space, determining a linear velocity for a given position. It does not produce any angular velocity.</p>
<p>The Circular DS can be constructed with a <code>CartesianState</code> state and radius as an argument; the state position defines the center of the limit cycle, while the state orientation defines the inclination of the limit cycle plane. The radius has a default value of 1.</p>
<p>The internal representation of the limit cycle is a <code><a class="el" href="classstate__representation_1_1_ellipsoid.html">state_representation::Ellipsoid</a></code> type.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// construction with the DS factory</span></div>
<div class="line"><span class="keyword">auto</span> ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::CIRCULAR);</div>
</div><!-- fragment --><h2>Configuring the Circular DS</h2>
<p>The Circular DS has the following core parameters:</p>
<ul>
<li><b>limit_cycle</b>; the <code>Ellipsoid</code> object defining the limit cycle center, shape and inclination.</li>
<li><b>planar_gain</b>; the proportional gain acting in the local plane towards the limit cycle radius.</li>
<li><b>normal_gain</b>; the proportional gain acting towards the local plane.</li>
<li><b>circular_velocity</b>; the expected angular orbital velocity around the local origin. Setting this value negative reverses the direction of rotation. [rad/s]</li>
</ul>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// update the parameters of the circular DS</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> center = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a>(<span class="stringliteral">&quot;center&quot;</span>);</div>
<div class="line"><span class="keywordtype">double</span> radius = 2.0;</div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_ellipsoid.html">state_representation::Ellipsoid</a> ellipse(<span class="stringliteral">&quot;limit_cycle&quot;</span>);</div>
<div class="line">ellipse.set_center_state(center);</div>
<div class="line">ellipse.set_axis_lengths({radius, 2 * radius});</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;limit_cycle&quot;</span>, ellipse);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> planar_gain = 1.0;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;planar_gain&quot;</span>, planar_gain);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> circular_velocity = M_PI / 2;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;circular_velocity&quot;</span>, circular_velocity);</div>
<div class="ttc" id="aclassstate__representation_1_1_ellipsoid_html"><div class="ttname"><a href="classstate__representation_1_1_ellipsoid.html">state_representation::Ellipsoid</a></div><div class="ttdef"><b>Definition</b> <a href="_ellipsoid_8hpp_source.html#l00012">Ellipsoid.hpp:12</a></div></div>
</div><!-- fragment --><h1>Ring</h1>
<p>The <b>Ring</b> DS is similar to the <b>Circular</b> DS but is more parameterizable. In brief, the strength of the limit cycle can be configured with a width around the ring radius.</p>
<p>The direction of the ring orbit is a positive rotation around the local Z axis; this appears as a counter-clockwise rotation when viewed from "above". A clockwise rotation can be achieved by rotating the ring 180 degrees about its local X or Y axis.</p>
<p>It only supports the <code>CartesianState</code> type, and always acts in a circular ring.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// construction with the DS factory</span></div>
<div class="line"><span class="keyword">auto</span> ds = CartesianDynamicalSystemFactory::create_dynamical_system(DYNAMICAL_SYSTEM_TYPE::RING);</div>
</div><!-- fragment --><h2>Configuring the Ring DS</h2>
<p>The Ring DS has the following core parameters:</p>
<ul>
<li><b>center</b>; the ring center <code>CartesianPose</code> expressed in the DS base reference frame. This sets both the origin center and the inclination of the ring plane.</li>
<li><b>rotation_offset</b>; the orientation offset of the orientational attractor in the ring frame.</li>
<li><b>radius</b>; the ring radius. [m]</li>
<li><b>width</b>; the distance from the radius where the velocity has tangential components around the ring. Beyond this width, the velocity is always perpendicular towards the radius. [m]</li>
<li><b>speed</b>; the desired linear speed when travelling along the circle radius. The limit cycle is only stable when the speed is positive. [m/s]</li>
<li><b>field_strength</b>; the scale factor applied to the ring speed outside of the radius + width zone.</li>
<li><b>normal_gain</b>; the scale factor for the speed normal to the ring plane.</li>
<li><b>angular_gain</b>; the scale factor for angular error restitution.</li>
</ul>
<p>Each parameter has corresponding <code>set_</code> and <code>get_</code> functions.</p>
<p>The constructor takes additional optional arguments to define the ring DS parameters. </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="comment">// update the ring DS parameters</span></div>
<div class="line"><a class="code hl_class" href="classstate__representation_1_1_cartesian_state.html">state_representation::CartesianState</a> center = <a class="code hl_function" href="classstate__representation_1_1_cartesian_state.html#a6c86224b5fed66d56e17f6772d247b59">state_representation::CartesianState::Identity</a>(<span class="stringliteral">&quot;center&quot;</span>);</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;center&quot;</span>, center);</div>
<div class="line"><span class="keywordtype">double</span> radius = 1.0;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;radius&quot;</span>, radius);</div>
<div class="line"><span class="keywordtype">double</span> width = 0.5;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;width&quot;</span>, width);</div>
<div class="line"><span class="keywordtype">double</span> speed = 1.0;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;speed&quot;</span>, speed);</div>
<div class="line"><span class="keywordtype">double</span> field_strength = 1.0;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;field_strength&quot;</span>, field_strength);</div>
<div class="line"><span class="keywordtype">double</span> normal_gain = 1.0;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;normal_gain&quot;</span>, normal_gain);</div>
<div class="line"><span class="keywordtype">double</span> angular_gain = 1.0;</div>
<div class="line">ds-&gt;set_parameter_value(<span class="stringliteral">&quot;angular_gain&quot;</span>, angular_gain);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
